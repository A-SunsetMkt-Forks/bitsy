<!DOCTYPE HTML>
<html>

<head>
	<title>bitsy mobile alpha</title>
</head>

<!-- STYLES -->
<link rel="stylesheet" type="text/css" href="../src/style/colorPickerStyle.css">

<!-- UTIL SCRIPTS -->
<script src="../src/script/color_util.js"></script>

<!-- ENGINE SCRIPTS -->
<script src="../src/script/font.js"></script>
<script src="../src/script/script.js"></script>
<script src="../src/script/dialog.js"></script>
<script src="../src/script/bitsy.js"></script>

<!-- EDITOR SCRIPTS -->
<script src="../src/script/color_picker.js"></script>

<script>
/*
GOALS
- mobile friendly UI
- bitsy v0.1 functionality
- better componentized code

IDEAS
- tools are one page each
- tools are **self contained**
- swipe to navigate tools?
- horizontal vs vertical mode
- zoom?
- how do you handle exporting games?

TODO
X game canvas
X game data
X play / pause
X resize to fit phone
X host somewhere
X title
X select tile / avatar / sprite
X edit map
- paint panel
X fix layout issues
- zoom
X figure out localhost -> mobile dev cycle
- fix color picker
- fix color slider

BUGS
- can't drag to delete tiles
X drag also moves player

Random thoughts
- title on EVERY room?
- how to distinguish between mobile / desktop tool versions?
- can we collapse distinction between different drawing types? avatar / sprite / tile / item

Components:
- room tool
- paint tool
- drawing selector

Shared code plan:
- sort code in prototype by tool / category
- pull out shared functions
- platform specialization
- componetization? (data-oriented or object-oriented? or?)
- also: componentize parser code

DEV NOTES:
- debug with safari
- host on localhost with: python -m SimpleHTTPServer
	- run from project root
- connect on iphone via: ip.address:8000/mobile
*/

function start() {
	attachCanvas( document.getElementById("game") );

	//load last auto-save
	if (localStorage.game_data) {
		document.getElementById("game_data").value = localStorage.game_data;
	}
	else {
		setDefaultGameState();
	}

	initGameState();
	// initGameStateAndRender(); // also parses and loads the data --- needs to be two separate things

	console.log("title : " + title);

	document.getElementById("titleText").value = title;

	// init color picker
	colorPicker = new ColorPicker('colorPickerWheel', 'colorPickerSelect', 'colorPickerSlider', 'colorPickerSliderBg', 'colorPickerHexText');
	colorPicker.onColorChange = onColorPickerChange;
	document.getElementById("colorPaletteOptionBackground").checked = true;
	updateColorPickerUI();

	document.getElementById("playModeCheck").checked = false;
	document.getElementById("tool_select").options[0].selected = true;

	drawEditMap();
	listenMapEditEvents();
}

function editGameData() {
	initGameStateAndRender();
	localStorage.game_data = document.getElementById("game_data").value;
}

function initGameState() {
	// re-import game data into the engine
	clearGameData();
	parseWorld(document.getElementById("game_data").value);
	renderImages();
}

function drawEditMap() {
	//clear screen
	ctx.fillStyle = "rgb("+getPal(curPal())[0][0]+","+getPal(curPal())[0][1]+","+getPal(curPal())[0][2]+")";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	//draw map
	console.log(room);
	drawRoom( room[curRoom] );

	//draw grid
	if (true /*drawMapGrid*/) {
		ctx.fillStyle = "#fff"; /*getContrastingColor();*/
		for (var x = 1; x < mapsize; x++) {
			ctx.fillRect(x*tilesize*scale,0*tilesize*scale,1,mapsize*tilesize*scale);
		}
		for (var y = 1; y < mapsize; y++) {
			ctx.fillRect(0*tilesize*scale,y*tilesize*scale,mapsize*tilesize*scale,1);
		}
	}
}

function initGameStateAndRender() {
	initGameState();
	drawEditMap();
}

function togglePlayMode(e) {
	if (e.target.checked) {
		on_play_mode();
	}
	else {
		on_edit_mode();
	}
	// updatePlayModeButton();
}

function on_play_mode() {
	// isPlayMode = true;
	unlistenMapEditEvents();
	load_game(document.getElementById("game_data").value /*, !isPreviewDialogMode*/ /* startWithTitle */);

	// console.log("PLAY!! ~~ PREVIEW ? " + isPreviewDialogMode);
	// if(!isPreviewDialogMode) {
		// console.log("DISALBE PREVIEW!!!");
		// document.getElementById("previewDialogCheck").disabled = true;
	// }
}

function on_edit_mode() {
	// isPlayMode = false;
	stopGame();
	// TODO I should really do more to separate the editor's game-data from the engine's game-data
	parseWorld(document.getElementById("game_data").value); //reparse world to account for any changes during gameplay
	// curRoom = sortedRoomIdList()[roomIndex]; //restore current room to pre-play state
	// drawEditMap();
	listenMapEditEvents();

	// updateInventoryUI();

	// if(isPreviewDialogMode) {
	// 	isPreviewDialogMode = false;
	// 	updatePreviewDialogButton();

	// 	for(var i = 0; i < advDialogUIComponents.length; i++) {
	// 		advDialogUIComponents[i].GetEl().classList.remove("highlighted");
	// 	}
	// }
	// document.getElementById("previewDialogCheck").disabled = false;

	initGameStateAndRender();
}

function changeTool(e) {
	Array.from( document.getElementsByClassName("tool") ).map( function(t) { t.style.display = "none"; } );
	document.getElementById(e.target.value).style.display = "block";
}

function on_change_title() {
	title = document.getElementById("titleText").value;
	refreshGameData();
}

function refreshGameData() {
	// if (isPlayMode) return; //never store game data while in playmode (TODO: wouldn't be necessary if the game data was decoupled form editor data)

	flags.ROOM_FORMAT = 1; // always save out comma separated format, even if the old format is read in
	var gameData = serializeWorld();
	//console.log("refresh!");
	//console.log(gameData);
	document.getElementById("game_data").value = gameData;
	localStorage.setItem("game_data", gameData); //auto-save
}

function newGameDialog() {
	// if ( confirm("Starting a new game will erase your old data. Consider exporting your work first! Are you sure you want to start over?") ) {
		resetGameData();
	// }
}

function resetGameData() {
	setDefaultGameState();

	// // todo wrap these variable resets in a function
	// tileIndex = 0;
	// spriteIndex = 0;

	// refreshGameData();
	// renderImages();
	// drawPaintCanvas();
	// drawEditMap();
	// updatePaletteUI();
	// // updatePaletteControlsFromGameData();
	// updateExitOptionsFromGameData();
	// updateRoomName();
	// updateInventoryUI();

	// on_paint_avatar();
	// document.getElementById('paintOptionAvatar').checked = true;

	initGameStateAndRender();
	updateColorPickerUI();
}

function setDefaultGameState() {
	// trying new way to get default game data
	document.getElementById("game_data").value = document.getElementById("defaultGameData").text.slice(1);
	localStorage.game_data = document.getElementById("game_data").value;
}

var colorPicker = null; // new color picker
var colorPickerIndex = 0;
var colorPaletteLabels = ["colorPaletteLabelBackground", "colorPaletteLabelTile", "colorPaletteLabelSprite"];

function changeColorPickerIndex(index) {
	colorPickerIndex = index;
	var color = getPal(selectedColorPal())[ index ];
	console.log(color);
	colorPicker.setColor( color[0], color[1], color[2] );
}

function updateColorPickerLabel(index, r, g, b) {
	var rgbColor = {r:r, g:g, b:b};

	var rgbColorStr = "rgb(" + rgbColor.r + "," + rgbColor.g + "," + rgbColor.b + ")";
	var hsvColor = RGBtoHSV( rgbColor );
	document.getElementById( colorPaletteLabels[ index ] ).style.background = rgbColorStr;
	document.getElementById( colorPaletteLabels[ index ] ).style.color = hsvColor.v < 0.5 ? "white" : "black";
}

function onColorPickerChange( rgbColor, isMouseUp ) {
	getPal(selectedColorPal())[ colorPickerIndex ][ 0 ] = rgbColor.r;
	getPal(selectedColorPal())[ colorPickerIndex ][ 1 ] = rgbColor.g;
	getPal(selectedColorPal())[ colorPickerIndex ][ 2 ] = rgbColor.b;

	updateColorPickerLabel(colorPickerIndex, rgbColor.r, rgbColor.g, rgbColor.b );

	if( isMouseUp ) {
		// refreshGameData();
		// renderImages();
		// drawPaintCanvas();
		// drawEditMap();
		// refreshPaintExplorer( true /*doKeepOldThumbnails*/ );
		// if( isCurDrawingAnimated )
		// 	renderAnimationPreview( drawingId );

		refreshGameData();
		initGameStateAndRender();
	}
}

function updateColorPickerUI() {
	var color0 = getPal(selectedColorPal())[ 0 ];
	var color1 = getPal(selectedColorPal())[ 1 ];
	var color2 = getPal(selectedColorPal())[ 2 ];

	updateColorPickerLabel(0, color0[0], color0[1], color0[2] );
	updateColorPickerLabel(1, color1[0], color1[1], color1[2] );
	updateColorPickerLabel(2, color2[0], color2[1], color2[2] );

	changeColorPickerIndex( colorPickerIndex );
}

function selectedColorPal() {
	return "0"; // TODO HACK
};

// hack copy
var TileType = {
	Tile : 0,
	Sprite : 1,
	Avatar : 2,
	Item : 3
};
// TODO: combine into one object?? curDrawing (for room)
var paintMode = TileType.Avatar;
var drawingId = "A";

function listenMapEditEvents() {
	// canvas.addEventListener("mousedown", map_onMouseDown);
	// canvas.addEventListener("mousemove", map_onMouseMove);
	// canvas.addEventListener("mouseup", map_onMouseUp);
	// canvas.addEventListener("mouseleave", map_onMouseUp);

	canvas.addEventListener("touchstart", map_onTouchStart);
	canvas.addEventListener("touchmove", map_onTouchMove);
	canvas.addEventListener("touchend", map_onTouchEnd);

	// mapEditAnimationLoop =
	// 	setInterval( function() {
	// 		animationCounter = animationTime + 1; // hack
	// 		updateAnimation();
	// 		drawEditMap();
	// 	}, animationTime ); // update animation in map mode
}

function unlistenMapEditEvents() {
	// canvas.removeEventListener("mousedown", map_onMouseDown);
	// canvas.removeEventListener("mousemove", map_onMouseMove);
	// canvas.removeEventListener("mouseup", map_onMouseUp);
	// canvas.removeEventListener("mouseleave", map_onMouseUp);

	canvas.removeEventListener("touchstart", map_onTouchStart);
	canvas.removeEventListener("touchmove", map_onTouchMove);
	canvas.removeEventListener("touchend", map_onTouchEnd);

	// clearInterval( mapEditAnimationLoop );
}

function mobileOffsetCorrection(off,e) {
	var bounds = e.target.getBoundingClientRect();

	// var width = bounds.width * containerRatio;
	// var height = bounds.height * containerRatio;

	// correction for square canvas contained in rect
	if( bounds.width > bounds.height ) {
		off.x -= (bounds.width - bounds.height) / 2;
	}
	else if( bounds.height > bounds.width ) {
		off.y -= (bounds.height - bounds.width) / 2;
	}

	console.log(off);

	// convert container size to internal canvas size
	var containerRatio = (tilesize*mapsize*scale) / Math.min( bounds.width, bounds.height );

	console.log(containerRatio);

	off.x *= containerRatio;
	off.y *= containerRatio;

	console.log(off);

	return off;
}

var isDragAddingTiles = false;
var isDragDeletingTiles = false;
// var isDragMovingExit = false;
// var isDragMovingEnding = false;
function map_onMouseDown(e) {
	var off = getOffset(e);

	console.log(off);

	off = mobileOffsetCorrection(off,e);

	console.log(off);

	var x = Math.floor( off.x / (tilesize*scale) );
	var y = Math.floor( off.y / (tilesize*scale) );
	// console.log(x + " " + y);

	// var didSelectedExitChange = areExitsVisible ? setSelectedExit( getExit(curRoom,x,y) ) : false;
	// var didSelectedEndingChange = areEndingsVisible ? setSelectedEnding( getEnding(curRoom,x,y) ) : false;

	// if (didSelectedExitChange || didSelectedEndingChange) {
	// 	//don't do anything else
	// 	if( selectedExit != null ) isDragMovingExit = true;
	// 	if( selectedEndingTile != null ) isDragMovingEnding = true;
	// }
	// else if (isAddingExit) { //todo - mutually exclusive with adding an ending?
	// 	//add exit
	// 	if ( getEnding(curRoom,x,y) == null && getExit(curRoom,x,y) == null ) {
	// 		addExitToCurRoom(x,y);
	// 	}
	// }
	// else if (isAddingEnding) {
	// 	//add ending
	// 	if ( getEnding(curRoom,x,y) == null && getExit(curRoom,x,y) == null ) {
	// 		addEndingToCurRoom(x,y);
	// 	}
	// }
	// else
	if (drawingId != null) {
		//add tiles/sprites to map
		console.log("DRAWING");
		if (paintMode == TileType.Tile) {
			if ( room[curRoom].tilemap[y][x] === "0" ) {
				console.log("ADD");
				//add
				//row = row.substr(0, x) + drawingId + row.substr(x+1);
				console.log( room[curRoom].tilemap );
				room[curRoom].tilemap[y][x] = drawingId;
				isDragAddingTiles = true;
			}
			else {
				//delete (better way to do this?)
				//row = row.substr(0, x) + "0" + row.substr(x+1);
				room[curRoom].tilemap[y][x] = "0";
				isDragDeletingTiles = true;
			}
			//room[curRoom].tilemap[y] = row;
		}
		else if( paintMode == TileType.Avatar || paintMode == TileType.Sprite ) {
			var otherSprite = getSpriteAt(x,y);
			var isThisSpriteAlreadyHere = sprite[drawingId].room === curRoom &&
										sprite[drawingId].x === x &&
										sprite[drawingId].y === y;

			if (otherSprite) {
				//remove other sprite from map
				sprite[otherSprite].room = null;
				sprite[otherSprite].x = -1;
				sprite[otherSprite].y = -1;
			}

			if (!isThisSpriteAlreadyHere) {
				//add sprite to map
				sprite[drawingId].room = curRoom;
				sprite[drawingId].x = x;
				sprite[drawingId].y = y;
				//row = row.substr(0, x) + "0" + row.substr(x+1); //is this necessary? no
			}
			else {
				//remove sprite from map
				sprite[drawingId].room = null;
				sprite[drawingId].x = -1;
				sprite[drawingId].y = -1;
			}
		}
		// else if( paintMode == TileType.Item ) {
		// 	// TODO : is this the final behavior I want?

		// 	var otherItem = getItem(curRoom,x,y);
		// 	var isThisItemAlreadyHere = otherItem != null && otherItem.id === drawingId;

		// 	if(otherItem) {
		// 		getRoom().items.splice( getRoom().items.indexOf(otherItem), 1 );
		// 	}

		// 	if(!isThisItemAlreadyHere) {
		// 		getRoom().items.push( {id:drawingId, x:x, y:y} );
		// 	}
		// }
		refreshGameData();
		drawEditMap();
	}
}

function editTilesOnDrag(e) {
	console.log("EDIT TILE - add? " + isDragAddingTiles + " delete? " + isDragDeletingTiles);

	var off = getOffset(e);

	off = mobileOffsetCorrection(off,e);

	var x = Math.floor(off.x / (tilesize*scale));
	var y = Math.floor(off.y / (tilesize*scale));
	// var row = room[curRoom].tilemap[y];
	if (isDragAddingTiles) {
		if ( room[curRoom].tilemap[y][x] != drawingId ) {
			// row = row.substr(0, x) + drawingId + row.substr(x+1);
			// room[curRoom].tilemap[y] = row;
			room[curRoom].tilemap[y][x] = drawingId;
			refreshGameData();
			drawEditMap();
		}
	}
	else if (isDragDeletingTiles) {
		if ( room[curRoom].tilemap[y][x] != "0" ) {
			// row = row.substr(0, x) + "0" + row.substr(x+1);
			// room[curRoom].tilemap[y] = row;
			room[curRoom].tilemap[y][x] = "0";
			refreshGameData();
			drawEditMap();
		}
	}
}

function map_onMouseMove(e) {
	// if( selectedExit != null && isDragMovingExit )
	// {
	// 	// drag exit around
	// 	var off = getOffset(e);
	// 	var x = Math.floor(off.x / (tilesize*scale));
	// 	var y = Math.floor(off.y / (tilesize*scale));
	// 	if( !getExit(curRoom,x,y) && !getEnding(curRoom,x,y) )
	// 	{
	// 		selectedExit.x = x;
	// 		selectedExit.y = y;
	// 		refreshGameData();
	// 		drawEditMap();	
	// 	}
	// }
	// else if( selectedEndingTile != null && isDragMovingEnding )
	// {
	// 	// drag ending around
	// 	var off = getOffset(e);
	// 	var x = Math.floor(off.x / (tilesize*scale));
	// 	var y = Math.floor(off.y / (tilesize*scale));
	// 	var y = Math.floor(off.y / (tilesize*scale));
	// 	if( !getExit(curRoom,x,y) && !getEnding(curRoom,x,y) )
	// 	{
	// 		selectedEndingTile.x = x;
	// 		selectedEndingTile.y = y;
	// 		refreshGameData();
	// 		drawEditMap();	
	// 	}
	// }
	// else
		editTilesOnDrag(e);
}

function map_onMouseUp(e) {
	editTilesOnDrag(e);
	isDragAddingTiles = false;
	isDragDeletingTiles = false;
	// isDragMovingExit = false;
	// isDragMovingEnding = false;
}

function map_onTouchStart(e) {
	map_onMouseDown(e.touches[0]);
}

function map_onTouchMove(e) {
	map_onMouseMove(e.touches[0]);
}

function map_onTouchEnd(e) {
	map_onMouseUp(e.touches[0]);
}

// TODO: these need to be specialized for ROOM and PAINT tools
function on_paint_avatar() {
	paintMode = TileType.Avatar;
	drawingId = "A";
	// reloadSprite();
	// document.getElementById("dialog").setAttribute("style","display:none;");
	// document.getElementById("wall").setAttribute("style","display:none;");
	// document.getElementById("paintNav").setAttribute("style","display:none;");
	// document.getElementById("paintCommands").setAttribute("style","display:none;");
	// document.getElementById("animationOuter").setAttribute("style","display:block;");
	// updateDrawingNameUI(false);
	// //document.getElementById("animation").setAttribute("style","display:none;");
	// refreshPaintExplorer();
	// document.getElementById("paintOptionAvatar").checked = true;
	// document.getElementById("paintExplorerOptionAvatar").checked = true;
	// document.getElementById("showInventoryButton").setAttribute("style","display:none;");
	// document.getElementById("paintExplorerAdd").setAttribute("style","display:none;");
	// document.getElementById("paintExplorerFilterInput").value = "";

	// reloadAdvDialogUI();


	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "none";
}
function on_paint_tile() {
	paintMode = TileType.Tile;
	tileIndex = 0;
	drawingId = sortedTileIdList()[tileIndex];
	// reloadTile();
	// document.getElementById("dialog").setAttribute("style","display:none;");
	// document.getElementById("wall").setAttribute("style","display:block;");
	// document.getElementById("paintNav").setAttribute("style","display:inline-block;");
	// document.getElementById("paintCommands").setAttribute("style","display:inline-block;");
	// document.getElementById("animationOuter").setAttribute("style","display:block;");
	// updateDrawingNameUI(true);
	// //document.getElementById("animation").setAttribute("style","display:block;");
	// refreshPaintExplorer();
	// document.getElementById("paintOptionTile").checked = true;
	// document.getElementById("paintExplorerOptionTile").checked = true;
	// document.getElementById("showInventoryButton").setAttribute("style","display:none;");
	// document.getElementById("paintExplorerAdd").setAttribute("style","display:inline-block;");
	// document.getElementById("paintExplorerFilterInput").value = "";

	// reloadAdvDialogUI();


	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedTileIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];
		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}
}
function on_paint_sprite() {
	paintMode = TileType.Sprite;
	if (sortedSpriteIdList().length > 1)
	{
		spriteIndex = 1;
	}
	else {
		spriteIndex = 0; //fall back to avatar if no other sprites exist
	}
	drawingId = sortedSpriteIdList()[spriteIndex];
	// curDrawingFrameIndex = 0;
	// reloadSprite();
	// document.getElementById("dialog").setAttribute("style","display:block;");
	// document.getElementById("wall").setAttribute("style","display:none;");
	// document.getElementById("paintNav").setAttribute("style","display:inline-block;");
	// document.getElementById("paintCommands").setAttribute("style","display:inline-block;");
	// document.getElementById("animationOuter").setAttribute("style","display:block;");
	// updateDrawingNameUI(true);
	// //document.getElementById("animation").setAttribute("style","display:block;");
	// refreshPaintExplorer();
	// document.getElementById("paintOptionSprite").checked = true;
	// document.getElementById("paintExplorerOptionSprite").checked = true;
	// document.getElementById("showInventoryButton").setAttribute("style","display:none;");
	// document.getElementById("paintExplorerAdd").setAttribute("style","display:inline-block;");
	// document.getElementById("paintExplorerFilterInput").value = "";

	// reloadAdvDialogUI();


	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedTileIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];

		if(id === "A")
			continue;

		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}
}

// TODO: these need to go into CORE code
function sortedTileIdList() {
	return sortedBase36IdList( tile );
}

function sortedSpriteIdList() {
	return sortedBase36IdList( sprite );
}

// function sortedItemIdList() {
// 	return sortedBase36IdList( item );
// }

// function sortedRoomIdList() {
// 	return sortedBase36IdList( room );
// }

// function sortedEndingIdList() {
// 	return sortedBase36IdList( ending );
// }

// function sortedPaletteIdList() {
// 	return sortedBase36IdList( palette );
// }

function sortedBase36IdList( objHolder ) {
	return Object.keys( objHolder ).sort( function(a,b) { return parseInt(a,36) - parseInt(b,36); } );
}

function onSelectDrawing(e) {
	drawingId = e.target.value;
}
</script>

<style>
	html {
		height: 100%;
	}
	body {
		margin: 0 !important;
		padding: 0 !important;
		height: 100%;
	}

	body, input[type=text], button, select {
		font-size: 18px;
	}

	canvas {
		background: black;
		width: 100%;
		height: 100%;
		object-fit: contain;
	}

	.flexRoot {
		/*background: red;*/
		display: flex;
		flex-flow: column;
		height: 100%;
		width: 100%;
	}

	@media screen and (orientation: landscape) {
	  .flexRoot {
	    flex-direction: row;
	  }
	}

	@media screen and (orientation: portrait) {
	  .flexRoot {
	    flex-direction: column;
	  }
	}

	.flexMain {
		/*background: green;*/
		flex: 2;
		padding: 20px;
	}

	.flexAlt {
		/*background: blue;*/
		flex: 1;
		padding: 20px;
	}

	.responsiveRoot {
		height: 100%;
		width: 100%;
	}

	.responsiveMain {
		background: blue;
		/*display: inline-block;*/
		/*margin: 0;*/
		float:left;
	}
	.responsiveAlt {
		background: red;
		/*display: inline-block;*/
		/*margin: 0;*/
		float:right;
	}
	.innerGap {
		margin: 5%;
		width: 90%;
		height: 90%;
	}

	@media screen and (orientation: landscape) {
		.responsiveMain {
			width: 60%;
			height: 100%;
		}
		.responsiveAlt {
			width: 40%;
			height: 100%;
		}
	}

	@media screen and (orientation: portrait) {
		.responsiveMain {
			width: 100%;
			height: 60%;
		}
		.responsiveAlt {
			width: 100%;
			height: 40%;
		}
	}

	#game_data {
		width: calc(100% - 40px);
		height: 60%;
		margin: 20px;

		/*display: none;*/
		/*width: 100%;*/
		/*height: 200px;*/
	}

	.tool {
		width:100%;height:95%;margin:auto;
	}

	#colorPicker {
		/*background: red;*/
		width: 100%;
		height: 100%;
		/*position: relative;*/
	}

	#colorPickerWheelOuter {
		width: 100%;
		height: 80%;
		position: relative;
		background: black;
	}

	#colorPickerWheel, #colorPickerSelect {
		/*background: black;*/
		width: 100%;
		height: 100%;
		margin: 0px;
		position: absolute;
		top: 0px;
		left: 0px;
		object-fit: contain;
	}

	#colorPickerHexText {
		width: 70%;
		/*margin: 0px;*/
		margin: auto;
		margin-top: 10px;
	}

	#colorPickerSliderBg {
		width: calc(70% - 8px);
		margin-left: 15%;
		/*margin:auto;*/
	}

	#colorPaletteForm input[type=radio]:checked + label {
		border: solid 4px black;
		padding-top: 20px;
		padding-bottom: 20px;
	}
</style>

<body onload="start();">
	<div style="width: 100%;height: 5%; background:green;">
		<span style="float:left;">bitsy mobile alpha</span>

		<span style="float:right;">
			tool :
			<select id="tool_select" onchange="changeTool(event);">
				<option value="tool_room">room</option>
				<option value="tool_paint">paint</option>
				<option value="tool_color">color</option>
				<option value="tool_data">data</option>
			</select>
		</span>
	</div>
	<div id="tool_room" class="tool">
		<div class="responsiveRoot">
			<div class="responsiveMain">
				<div class="innerGap">
					<canvas id="game"></canvas>
				</div>
			</div>
			<div class="responsiveAlt">
				<div class="innerGap">
					<input type="checkbox" id="playModeCheck" onclick="togglePlayMode(event);" />
					<label title="play / pause game" for="playModeCheck">
						<!-- <i class="material-icons" id="playModeIcon">play_arrow</i> -->
						<span id="playModeText"> play </span>
					</label>

					<br/><br/>

					title : 
					<input title="title text for your game" type="text" id="titleText" onchange="on_change_title();" value="Write your game's title here" placeholder="Title">

					<br/><br/>

					<form>
						paint : 

						<input type="radio" name="paint mode" value="avatar" onclick="on_paint_avatar();" id="paintOptionAvatar" checked>
						<label title="edit the avatar: the player's character" for="paintOptionAvatar" class="left">
							<!-- <i class="material-icons">perm_identity</i> -->
							avatar
						</label>

						<input type="radio" name="paint mode" value="tile" onclick="on_paint_tile();" id="paintOptionTile">
						<label title="edit tiles: pieces of scenery" for="paintOptionTile" class="middle">
							<!-- <i class="material-icons">terrain</i> -->
							tile
						</label>

						<input type="radio" name="paint mode" value="sprite" onclick="on_paint_sprite();" id="paintOptionSprite">
						<label title="edit sprites: non-player characters and interactive objects" for="paintOptionSprite" class="middle">
							<!-- <i class="material-icons">nature_people</i> -->
							sprite
						</label>
					</form>

					<select id="drawing_select" onchange="onSelectDrawing(event);">
					</select>
				</div>
			</div>
		</div>
	</div>
	<div id="tool_paint" class="tool" style="display:none;">
		paint
	</div>
	<div id="tool_color" class="tool" style="display:none;">
		<div class="flexRoot">
			<div class="flexMain">
				<div id="colorPicker" title="color picker">
					<div id="colorPickerWheelOuter">
						<canvas id="colorPickerWheel"></canvas>
						<canvas id="colorPickerSelect" title="color picker wheel"></canvas>
					</div>
					<div id="colorPickerSliderBg" title="color picker darkness / lightness slider">
						<input type="range" id="colorPickerSlider" value="0" />
					</div>
					<input id="colorPickerHexText" title="color picker hex code" type="text" />
				</div>
			</div>
			<div class="flexAlt">
				<form id="colorPaletteForm">
					<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionBackground" onclick="changeColorPickerIndex(0);" checked>
					<label id="colorPaletteLabelBackground" for="colorPaletteOptionBackground" title="pick background color">
						<!-- <i class="material-icons">grid_on</i> -->
						background color
					</label>

					<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionTile" onclick="changeColorPickerIndex(1);">
					<label id="colorPaletteLabelTile" for="colorPaletteOptionTile" title="pick tile color">
						<!-- <i class="material-icons">terrain</i> -->
						tile color
					</label>

					<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionSprite" onclick="changeColorPickerIndex(2);">
					<label id="colorPaletteLabelSprite" for="colorPaletteOptionSprite" title="pick sprite / avatar / item color">
						<!-- <i class="material-icons">nature_people</i> -->
						sprite color
					</label>
				</form>
			</div>
		</div>
	</div>
	<div id="tool_data" class="tool" style="display:none;">
		<button title="reset everything and start new game" class="color0" onclick="newGameDialog();">
			<!-- <i class="material-icons">restore_page</i> -->
			reset game data
		</button>
		<textarea id="game_data" onchange="editGameData();"></textarea>
	</div>
</body>

<script type="bitsyGameData" id="defaultGameData">
Write your game's title here

# BITSY VERSION 4.6

! ROOM_FORMAT 1

PAL 0
0,82,204
128,159,255
255,255,255

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PAL 0

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111

SPR A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
POS 0 4,4

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
DLG SPR_0
POS 0 8,12

ITM 0
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea
DLG ITM_0

DLG SPR_0
I'm a cat

DLG ITM_0
You found a nice warm cup of tea

VAR a
42
</script>

</html>