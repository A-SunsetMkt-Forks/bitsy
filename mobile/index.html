<!DOCTYPE HTML>
<html>

<head>
	<title>bitsy mobile alpha</title>
</head>

<!-- STYLES -->
<link rel="stylesheet" type="text/css" href="../src/style/colorPickerStyle.css">

<!-- UTIL SCRIPTS -->
<script src="../src/script/color_util.js"></script>

<!-- ENGINE SCRIPTS -->
<script src="../src/script/font.js"></script>
<script src="../src/script/script.js"></script>
<script src="../src/script/dialog.js"></script>
<script src="../src/script/bitsy.js"></script>

<!-- EDITOR SCRIPTS -->
<script src="../src/script/color_picker.js"></script>

<script>
/*
GOALS
- mobile friendly UI
- bitsy v0.1 functionality
- better componentized code

IDEAS
- tools are one page each
- tools are **self contained**
- swipe to navigate tools?
- horizontal vs vertical mode
- zoom?
- how do you handle exporting games?

TODO
X game canvas
X game data
X play / pause
X resize to fit phone
X host somewhere
X title
X select tile / avatar / sprite
X edit map
- paint panel
	X dialog
	X wall
	- add
	- delete
X fix layout issues
- zoom
X figure out localhost -> mobile dev cycle
- fix color picker
- fix color slider
X font size issue (currently fixed by making it big?)

BUGS
X can't drag to delete tiles
X drag also moves player

Random thoughts
- title on EVERY room?
- how to distinguish between mobile / desktop tool versions?
- can we collapse distinction between different drawing types? avatar / sprite / tile / item
- SFX?
- tools as iframes?

Components:
- room tool
- paint tool
- color picker (done-ish)
- drawing selector
- data panel

Shared code plan:
- sort code in prototype by tool / category
- pull out shared functions
- platform specialization
- componetization? (data-oriented or object-oriented? or?)
- also: componentize parser code

DEV NOTES:
- debug with safari
- host on localhost with: python -m SimpleHTTPServer
	- run from project root
- connect on iphone via: ip.address:8000/mobile
*/

function start() {
	attachCanvas( document.getElementById("game") );

	//load last auto-save
	if (localStorage.game_data) {
		document.getElementById("game_data").value = localStorage.game_data;
	}
	else {
		setDefaultGameState();
	}

	initGameState();
	// initGameStateAndRender(); // also parses and loads the data --- needs to be two separate things

	// console.log("title : " + title);

	document.getElementById("titleText").value = title;

	initPaintCanvas();
	drawPaintCanvas();

	// init color picker
	colorPicker = new ColorPicker('colorPickerWheel', 'colorPickerSelect', 'colorPickerSlider', 'colorPickerSliderBg', 'colorPickerHexText');
	colorPicker.onColorChange = onColorPickerChange;
	document.getElementById("colorPaletteOptionBackground").checked = true;
	updateColorPickerUI();

	document.getElementById("playModeCheck").checked = false;
	document.getElementById("tool_select").options[0].selected = true;

	drawEditMap();
	listenMapEditEvents();
}

function editGameData() {
	initGameStateAndRender();
	localStorage.game_data = document.getElementById("game_data").value;
}

function initGameState() {
	// re-import game data into the engine
	clearGameData();
	parseWorld(document.getElementById("game_data").value);
	renderImages();
}

function drawEditMap() {
	//clear screen
	ctx.fillStyle = "rgb("+getPal(curPal())[0][0]+","+getPal(curPal())[0][1]+","+getPal(curPal())[0][2]+")";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	//draw map
	console.log(room);
	drawRoom( room[curRoom] );

	//draw grid
	if (true /*drawMapGrid*/) {
		ctx.fillStyle = getContrastingColor();
		for (var x = 1; x < mapsize; x++) {
			ctx.fillRect(x*tilesize*scale,0*tilesize*scale,1,mapsize*tilesize*scale);
		}
		for (var y = 1; y < mapsize; y++) {
			ctx.fillRect(0*tilesize*scale,y*tilesize*scale,mapsize*tilesize*scale,1);
		}
	}
}

function initGameStateAndRender() {
	initGameState();
	drawEditMap();
}

function togglePlayMode(e) {
	if (e.target.checked) {
		on_play_mode();
	}
	else {
		on_edit_mode();
	}
	// updatePlayModeButton();
}

function on_play_mode() {
	// isPlayMode = true;
	unlistenMapEditEvents();
	load_game(document.getElementById("game_data").value /*, !isPreviewDialogMode*/ /* startWithTitle */);

	// console.log("PLAY!! ~~ PREVIEW ? " + isPreviewDialogMode);
	// if(!isPreviewDialogMode) {
		// console.log("DISALBE PREVIEW!!!");
		// document.getElementById("previewDialogCheck").disabled = true;
	// }
}

function on_edit_mode() {
	// isPlayMode = false;
	stopGame();
	// TODO I should really do more to separate the editor's game-data from the engine's game-data
	parseWorld(document.getElementById("game_data").value); //reparse world to account for any changes during gameplay
	// curRoom = sortedRoomIdList()[roomIndex]; //restore current room to pre-play state
	// drawEditMap();
	listenMapEditEvents();

	// updateInventoryUI();

	// if(isPreviewDialogMode) {
	// 	isPreviewDialogMode = false;
	// 	updatePreviewDialogButton();

	// 	for(var i = 0; i < advDialogUIComponents.length; i++) {
	// 		advDialogUIComponents[i].GetEl().classList.remove("highlighted");
	// 	}
	// }
	// document.getElementById("previewDialogCheck").disabled = false;

	initGameStateAndRender();
}

function changeTool(e) {
	Array.from( document.getElementsByClassName("tool") ).map( function(t) { t.style.display = "none"; } );
	document.getElementById(e.target.value).style.display = "block";
}

function on_change_title() {
	title = document.getElementById("titleText").value;
	refreshGameData();
}

function refreshGameData() {
	// if (isPlayMode) return; //never store game data while in playmode (TODO: wouldn't be necessary if the game data was decoupled form editor data)

	flags.ROOM_FORMAT = 1; // always save out comma separated format, even if the old format is read in
	var gameData = serializeWorld();
	//console.log("refresh!");
	//console.log(gameData);
	document.getElementById("game_data").value = gameData;
	localStorage.setItem("game_data", gameData); //auto-save
}

function newGameDialog() {
	// if ( confirm("Starting a new game will erase your old data. Consider exporting your work first! Are you sure you want to start over?") ) {
		resetGameData();
	// }
}

function resetGameData() {
	setDefaultGameState();

	// // todo wrap these variable resets in a function
	// tileIndex = 0;
	// spriteIndex = 0;

	// refreshGameData();
	// renderImages();
	// drawPaintCanvas();
	// drawEditMap();
	// updatePaletteUI();
	// // updatePaletteControlsFromGameData();
	// updateExitOptionsFromGameData();
	// updateRoomName();
	// updateInventoryUI();

	// on_paint_avatar();
	// document.getElementById('paintOptionAvatar').checked = true;

	initGameStateAndRender();
	updateColorPickerUI();
}

function setDefaultGameState() {
	// trying new way to get default game data
	document.getElementById("game_data").value = document.getElementById("defaultGameData").text.slice(1);
	localStorage.game_data = document.getElementById("game_data").value;
}

var colorPicker = null; // new color picker
var colorPickerIndex = 0;
var colorPaletteLabels = ["colorPaletteLabelBackground", "colorPaletteLabelTile", "colorPaletteLabelSprite"];

function changeColorPickerIndex(index) {
	colorPickerIndex = index;
	var color = getPal(selectedColorPal())[ index ];
	console.log(color);
	colorPicker.setColor( color[0], color[1], color[2] );
}

function updateColorPickerLabel(index, r, g, b) {
	var rgbColor = {r:r, g:g, b:b};

	var rgbColorStr = "rgb(" + rgbColor.r + "," + rgbColor.g + "," + rgbColor.b + ")";
	var hsvColor = RGBtoHSV( rgbColor );
	document.getElementById( colorPaletteLabels[ index ] ).style.background = rgbColorStr;
	document.getElementById( colorPaletteLabels[ index ] ).style.color = hsvColor.v < 0.5 ? "white" : "black";
}

function onColorPickerChange( rgbColor, isMouseUp ) {
	getPal(selectedColorPal())[ colorPickerIndex ][ 0 ] = rgbColor.r;
	getPal(selectedColorPal())[ colorPickerIndex ][ 1 ] = rgbColor.g;
	getPal(selectedColorPal())[ colorPickerIndex ][ 2 ] = rgbColor.b;

	updateColorPickerLabel(colorPickerIndex, rgbColor.r, rgbColor.g, rgbColor.b );

	if( isMouseUp ) {
		// refreshGameData();
		// renderImages();
		// drawPaintCanvas();
		// drawEditMap();
		// refreshPaintExplorer( true /*doKeepOldThumbnails*/ );
		// if( isCurDrawingAnimated )
		// 	renderAnimationPreview( drawingId );

		refreshGameData();
		initGameStateAndRender();
	}
}

function updateColorPickerUI() {
	var color0 = getPal(selectedColorPal())[ 0 ];
	var color1 = getPal(selectedColorPal())[ 1 ];
	var color2 = getPal(selectedColorPal())[ 2 ];

	updateColorPickerLabel(0, color0[0], color0[1], color0[2] );
	updateColorPickerLabel(1, color1[0], color1[1], color1[2] );
	updateColorPickerLabel(2, color2[0], color2[1], color2[2] );

	changeColorPickerIndex( colorPickerIndex );
}

function selectedColorPal() {
	return "0"; // TODO HACK
};

// hack copy
var TileType = {
	Tile : 0,
	Sprite : 1,
	Avatar : 2,
	Item : 3
};
// TODO: combine into one object?? curDrawing (for room)
var paintMode = TileType.Avatar;
var drawingId = "A";

function listenMapEditEvents() {
	// canvas.addEventListener("mousedown", map_onMouseDown);
	// canvas.addEventListener("mousemove", map_onMouseMove);
	// canvas.addEventListener("mouseup", map_onMouseUp);
	// canvas.addEventListener("mouseleave", map_onMouseUp);

	canvas.addEventListener("touchstart", map_onTouchStart);
	canvas.addEventListener("touchmove", map_onTouchMove);
	canvas.addEventListener("touchend", map_onTouchEnd);

	// mapEditAnimationLoop =
	// 	setInterval( function() {
	// 		animationCounter = animationTime + 1; // hack
	// 		updateAnimation();
	// 		drawEditMap();
	// 	}, animationTime ); // update animation in map mode
}

function unlistenMapEditEvents() {
	// canvas.removeEventListener("mousedown", map_onMouseDown);
	// canvas.removeEventListener("mousemove", map_onMouseMove);
	// canvas.removeEventListener("mouseup", map_onMouseUp);
	// canvas.removeEventListener("mouseleave", map_onMouseUp);

	canvas.removeEventListener("touchstart", map_onTouchStart);
	canvas.removeEventListener("touchmove", map_onTouchMove);
	canvas.removeEventListener("touchend", map_onTouchEnd);

	// clearInterval( mapEditAnimationLoop );
}

function mobileOffsetCorrection(off,e,innerSize) {
	var bounds = e.target.getBoundingClientRect();

	// var width = bounds.width * containerRatio;
	// var height = bounds.height * containerRatio;

	// correction for square canvas contained in rect
	if( bounds.width > bounds.height ) {
		off.x -= (bounds.width - bounds.height) / 2;
	}
	else if( bounds.height > bounds.width ) {
		off.y -= (bounds.height - bounds.width) / 2;
	}

	console.log(off);

	// convert container size to internal canvas size
	var containerRatio = innerSize / Math.min( bounds.width, bounds.height );

	console.log(containerRatio);

	off.x *= containerRatio;
	off.y *= containerRatio;

	console.log(off);

	return off;
}

var isDragAddingTiles = false;
var isDragDeletingTiles = false;
// var isDragMovingExit = false;
// var isDragMovingEnding = false;
function map_onMouseDown(e) {
	var off = getOffset(e);

	console.log(off);

	off = mobileOffsetCorrection(off,e,(tilesize*mapsize*scale));

	console.log(off);

	var x = Math.floor( off.x / (tilesize*scale) );
	var y = Math.floor( off.y / (tilesize*scale) );
	// console.log(x + " " + y);

	// var didSelectedExitChange = areExitsVisible ? setSelectedExit( getExit(curRoom,x,y) ) : false;
	// var didSelectedEndingChange = areEndingsVisible ? setSelectedEnding( getEnding(curRoom,x,y) ) : false;

	// if (didSelectedExitChange || didSelectedEndingChange) {
	// 	//don't do anything else
	// 	if( selectedExit != null ) isDragMovingExit = true;
	// 	if( selectedEndingTile != null ) isDragMovingEnding = true;
	// }
	// else if (isAddingExit) { //todo - mutually exclusive with adding an ending?
	// 	//add exit
	// 	if ( getEnding(curRoom,x,y) == null && getExit(curRoom,x,y) == null ) {
	// 		addExitToCurRoom(x,y);
	// 	}
	// }
	// else if (isAddingEnding) {
	// 	//add ending
	// 	if ( getEnding(curRoom,x,y) == null && getExit(curRoom,x,y) == null ) {
	// 		addEndingToCurRoom(x,y);
	// 	}
	// }
	// else
	if (drawingId != null) {
		//add tiles/sprites to map
		console.log("DRAWING");
		if (paintMode == TileType.Tile) {
			if ( room[curRoom].tilemap[y][x] === "0" ) {
				console.log("ADD");
				//add
				//row = row.substr(0, x) + drawingId + row.substr(x+1);
				console.log( room[curRoom].tilemap );
				room[curRoom].tilemap[y][x] = drawingId;
				isDragAddingTiles = true;
			}
			else {
				//delete (better way to do this?)
				//row = row.substr(0, x) + "0" + row.substr(x+1);
				room[curRoom].tilemap[y][x] = "0";
				isDragDeletingTiles = true;
			}
			//room[curRoom].tilemap[y] = row;
		}
		else if( paintMode == TileType.Avatar || paintMode == TileType.Sprite ) {
			var otherSprite = getSpriteAt(x,y);
			var isThisSpriteAlreadyHere = sprite[drawingId].room === curRoom &&
										sprite[drawingId].x === x &&
										sprite[drawingId].y === y;

			if (otherSprite) {
				//remove other sprite from map
				sprite[otherSprite].room = null;
				sprite[otherSprite].x = -1;
				sprite[otherSprite].y = -1;
			}

			if (!isThisSpriteAlreadyHere) {
				//add sprite to map
				sprite[drawingId].room = curRoom;
				sprite[drawingId].x = x;
				sprite[drawingId].y = y;
				//row = row.substr(0, x) + "0" + row.substr(x+1); //is this necessary? no
			}
			else {
				//remove sprite from map
				sprite[drawingId].room = null;
				sprite[drawingId].x = -1;
				sprite[drawingId].y = -1;
			}
		}
		// else if( paintMode == TileType.Item ) {
		// 	// TODO : is this the final behavior I want?

		// 	var otherItem = getItem(curRoom,x,y);
		// 	var isThisItemAlreadyHere = otherItem != null && otherItem.id === drawingId;

		// 	if(otherItem) {
		// 		getRoom().items.splice( getRoom().items.indexOf(otherItem), 1 );
		// 	}

		// 	if(!isThisItemAlreadyHere) {
		// 		getRoom().items.push( {id:drawingId, x:x, y:y} );
		// 	}
		// }
		refreshGameData();
		drawEditMap();
	}
}

function editTilesOnDrag(e) {
	console.log("EDIT TILE - add? " + isDragAddingTiles + " delete? " + isDragDeletingTiles);

	var off = getOffset(e);

	off = mobileOffsetCorrection(off,e,(tilesize*mapsize*scale));

	var x = Math.floor(off.x / (tilesize*scale));
	var y = Math.floor(off.y / (tilesize*scale));
	// var row = room[curRoom].tilemap[y];
	if (isDragAddingTiles) {
		if ( room[curRoom].tilemap[y][x] != drawingId ) {
			// row = row.substr(0, x) + drawingId + row.substr(x+1);
			// room[curRoom].tilemap[y] = row;
			room[curRoom].tilemap[y][x] = drawingId;
			refreshGameData();
			drawEditMap();
		}
	}
	else if (isDragDeletingTiles) {
		if ( room[curRoom].tilemap[y][x] != "0" ) {
			// row = row.substr(0, x) + "0" + row.substr(x+1);
			// room[curRoom].tilemap[y] = row;
			room[curRoom].tilemap[y][x] = "0";
			refreshGameData();
			drawEditMap();
		}
	}
}

function map_onMouseMove(e) {
	// if( selectedExit != null && isDragMovingExit )
	// {
	// 	// drag exit around
	// 	var off = getOffset(e);
	// 	var x = Math.floor(off.x / (tilesize*scale));
	// 	var y = Math.floor(off.y / (tilesize*scale));
	// 	if( !getExit(curRoom,x,y) && !getEnding(curRoom,x,y) )
	// 	{
	// 		selectedExit.x = x;
	// 		selectedExit.y = y;
	// 		refreshGameData();
	// 		drawEditMap();	
	// 	}
	// }
	// else if( selectedEndingTile != null && isDragMovingEnding )
	// {
	// 	// drag ending around
	// 	var off = getOffset(e);
	// 	var x = Math.floor(off.x / (tilesize*scale));
	// 	var y = Math.floor(off.y / (tilesize*scale));
	// 	var y = Math.floor(off.y / (tilesize*scale));
	// 	if( !getExit(curRoom,x,y) && !getEnding(curRoom,x,y) )
	// 	{
	// 		selectedEndingTile.x = x;
	// 		selectedEndingTile.y = y;
	// 		refreshGameData();
	// 		drawEditMap();	
	// 	}
	// }
	// else
		editTilesOnDrag(e);
}

function map_onMouseUp(e) {
	editTilesOnDrag(e);
	isDragAddingTiles = false;
	isDragDeletingTiles = false;
	// isDragMovingExit = false;
	// isDragMovingEnding = false;
}

function map_onTouchStart(e) {
	e.preventDefault();
	// console.log(e.touches[0]);
	var fakeEvent = { target:e.target, clientX:e.touches[0].clientX, clientY:e.touches[0].clientY };
	// console.log(fakeEvent);
	map_onMouseDown( fakeEvent );
}

function map_onTouchMove(e) {
	e.preventDefault();
	var fakeEvent = { target:e.target, clientX:e.touches[0].clientX, clientY:e.touches[0].clientY };
	map_onMouseMove( fakeEvent );
}

function map_onTouchEnd(e) {
	e.preventDefault();
	// var fakeEvent = { target:e.target, clientX:e.touches[0].clientX, clientY:e.touches[0].clientY };
	// map_onMouseUp( fakeEvent );
	isDragAddingTiles = false;
	isDragDeletingTiles = false;
}

// TODO: these need to be specialized for ROOM and PAINT tools
function on_room_paint_avatar() {
	paintMode = TileType.Avatar;
	drawingId = "A";
	// reloadSprite();
	// document.getElementById("dialog").setAttribute("style","display:none;");
	// document.getElementById("wall").setAttribute("style","display:none;");
	// document.getElementById("paintNav").setAttribute("style","display:none;");
	// document.getElementById("paintCommands").setAttribute("style","display:none;");
	// document.getElementById("animationOuter").setAttribute("style","display:block;");
	// updateDrawingNameUI(false);
	// //document.getElementById("animation").setAttribute("style","display:none;");
	// refreshPaintExplorer();
	// document.getElementById("paintOptionAvatar").checked = true;
	// document.getElementById("paintExplorerOptionAvatar").checked = true;
	// document.getElementById("showInventoryButton").setAttribute("style","display:none;");
	// document.getElementById("paintExplorerAdd").setAttribute("style","display:none;");
	// document.getElementById("paintExplorerFilterInput").value = "";

	// reloadAdvDialogUI();


	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "none";
}
function on_room_paint_tile() {
	paintMode = TileType.Tile;
	tileIndex = 0;
	drawingId = sortedTileIdList()[tileIndex];
	// reloadTile();
	// document.getElementById("dialog").setAttribute("style","display:none;");
	// document.getElementById("wall").setAttribute("style","display:block;");
	// document.getElementById("paintNav").setAttribute("style","display:inline-block;");
	// document.getElementById("paintCommands").setAttribute("style","display:inline-block;");
	// document.getElementById("animationOuter").setAttribute("style","display:block;");
	// updateDrawingNameUI(true);
	// //document.getElementById("animation").setAttribute("style","display:block;");
	// refreshPaintExplorer();
	// document.getElementById("paintOptionTile").checked = true;
	// document.getElementById("paintExplorerOptionTile").checked = true;
	// document.getElementById("showInventoryButton").setAttribute("style","display:none;");
	// document.getElementById("paintExplorerAdd").setAttribute("style","display:inline-block;");
	// document.getElementById("paintExplorerFilterInput").value = "";

	// reloadAdvDialogUI();


	// update options
	var selectDrawing = document.getElementById("room_drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedTileIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];
		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}
}
function on_room_paint_sprite() {
	paintMode = TileType.Sprite;
	if (sortedSpriteIdList().length > 1)
	{
		spriteIndex = 1;
	}
	else {
		spriteIndex = 0; //fall back to avatar if no other sprites exist
	}
	drawingId = sortedSpriteIdList()[spriteIndex];
	// curDrawingFrameIndex = 0;
	// reloadSprite();
	// document.getElementById("dialog").setAttribute("style","display:block;");
	// document.getElementById("wall").setAttribute("style","display:none;");
	// document.getElementById("paintNav").setAttribute("style","display:inline-block;");
	// document.getElementById("paintCommands").setAttribute("style","display:inline-block;");
	// document.getElementById("animationOuter").setAttribute("style","display:block;");
	// updateDrawingNameUI(true);
	// //document.getElementById("animation").setAttribute("style","display:block;");
	// refreshPaintExplorer();
	// document.getElementById("paintOptionSprite").checked = true;
	// document.getElementById("paintExplorerOptionSprite").checked = true;
	// document.getElementById("showInventoryButton").setAttribute("style","display:none;");
	// document.getElementById("paintExplorerAdd").setAttribute("style","display:inline-block;");
	// document.getElementById("paintExplorerFilterInput").value = "";

	// reloadAdvDialogUI();


	// update options
	var selectDrawing = document.getElementById("room_drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedSpriteIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];

		if(id === "A")
			continue;

		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}
}

// TODO: these need to be specialized for ROOM and PAINT tools
function on_paint_avatar() {
	paint_paintMode = TileType.Avatar;
	paint_drawingId = "A";

	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "none";

	drawPaintCanvas();

	document.getElementById("dialog").setAttribute("style","display:none;");
	document.getElementById("wall").setAttribute("style","display:none;");
}
function on_paint_tile() {
	paint_paintMode = TileType.Tile;
	paint_drawingId = sortedTileIdList()[0];

	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedTileIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];
		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}

	reloadTile();
	drawPaintCanvas();

	document.getElementById("dialog").setAttribute("style","display:none;");
	document.getElementById("wall").setAttribute("style","display:block;");
}
function on_paint_sprite() {
	paint_paintMode = TileType.Sprite;
	paint_drawingId = sortedSpriteIdList()[sortedSpriteIdList().length > 1 ? 1 : 0];

	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedSpriteIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];

		if(id === "A")
			continue;

		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}

	reloadSprite();

	drawPaintCanvas();

	document.getElementById("dialog").setAttribute("style","display:block;");
	document.getElementById("wall").setAttribute("style","display:none;");
}

// TODO: these need to go into CORE code
function sortedTileIdList() {
	return sortedBase36IdList( tile );
}

function sortedSpriteIdList() {
	return sortedBase36IdList( sprite );
}

// function sortedItemIdList() {
// 	return sortedBase36IdList( item );
// }

// function sortedRoomIdList() {
// 	return sortedBase36IdList( room );
// }

// function sortedEndingIdList() {
// 	return sortedBase36IdList( ending );
// }

// function sortedPaletteIdList() {
// 	return sortedBase36IdList( palette );
// }

function sortedBase36IdList( objHolder ) {
	return Object.keys( objHolder ).sort( function(a,b) { return parseInt(a,36) - parseInt(b,36); } );
}

function room_onSelectDrawing(e) {
	drawingId = e.target.value;
}
function paint_onSelectDrawing(e) {
	paint_drawingId = e.target.value;
	drawPaintCanvas();

	// TODO : make these functions less hacky and terrible
	if(paint_paintMode == TileType.Tile) {
		reloadTile();
	}
	else if(paint_paintMode == TileType.Sprite) {
		reloadSprite();
	}
}

/* PAINT STUFF */
var paint_paintMode = TileType.Avatar;
var paint_drawingId = "A";

var paint_canvas;
var paint_ctx;
var paint_scale = 32;

var drawPaintGrid = true;
var curPaintBrush = 0;
var isPainting = false;
var isCurDrawingAnimated = false;
var curDrawingFrameIndex = 0;

function initPaintCanvas() {
	//paint canvas & context
	paint_canvas = document.getElementById("paint");
	paint_canvas.width = tilesize * paint_scale;
	paint_canvas.height = tilesize * paint_scale;
	paint_ctx = paint_canvas.getContext("2d");

	//paint events
	// paint_canvas.addEventListener("mousedown", paint_onMouseDown);
	// paint_canvas.addEventListener("mousemove", paint_onMouseMove);
	// paint_canvas.addEventListener("mouseup", paint_onMouseUp);
	// paint_canvas.addEventListener("mouseleave", paint_onMouseUp);

	paint_canvas.addEventListener("touchstart", paint_onTouchStart);
	paint_canvas.addEventListener("touchmove", paint_onTouchMove);
	paint_canvas.addEventListener("touchend", paint_onTouchEnd);
}

function paint_onMouseDown(e) {
	// if (isPlayMode) return; //can't paint during play mode

	var off = getOffset(e);

	off = mobileOffsetCorrection(off,e,(tilesize));

	var x = Math.floor(off.x);
	var y = Math.floor(off.y);

	// non-responsive version
	// var x = Math.floor(off.x / paint_scale);
	// var y = Math.floor(off.y / paint_scale);

	if (curDrawingData()[y][x] == 0) {
		curPaintBrush = 1;
	}
	else {
		curPaintBrush = 0;
	}
	curDrawingData()[y][x] = curPaintBrush;
	drawPaintCanvas();
	isPainting = true;
}

function paint_onMouseMove(e) {
	if (isPainting) {	
		var off = getOffset(e);

		off = mobileOffsetCorrection(off,e,(tilesize));

		var x = Math.floor(off.x);// / paint_scale);
		var y = Math.floor(off.y);// / paint_scale);
		curDrawingData()[y][x] = curPaintBrush;
		drawPaintCanvas();
	}
}

function paint_onMouseUp(e) {
	if (isPainting) {
		isPainting = false;
		renderImages();
		refreshGameData();
		drawEditMap();
		// renderPaintThumbnail( drawingId );
		// if( isCurDrawingAnimated )
		// 	renderAnimationPreview( drawingId );
	}
}

function paint_onTouchStart(e) {
	e.preventDefault();
	var fakeEvent = { target:e.target, clientX:e.touches[0].clientX, clientY:e.touches[0].clientY };
	paint_onMouseDown(fakeEvent);
}

function paint_onTouchMove(e) {
	e.preventDefault();
	var fakeEvent = { target:e.target, clientX:e.touches[0].clientX, clientY:e.touches[0].clientY };
	paint_onMouseMove(fakeEvent);
}

function paint_onTouchEnd(e) {
	e.preventDefault();
	paint_onMouseUp();
}

function drawPaintCanvas() {
	//background
	paint_ctx.fillStyle = "rgb("+getPal(curPal())[0][0]+","+getPal(curPal())[0][1]+","+getPal(curPal())[0][2]+")";
	paint_ctx.fillRect(0,0,canvas.width,canvas.height);

	//pixel color
	if (paintMode == TileType.Tile) {
		paint_ctx.fillStyle = "rgb("+getPal(curPal())[1][0]+","+getPal(curPal())[1][1]+","+getPal(curPal())[1][2]+")";
	}
	else if (paintMode == TileType.Sprite || paintMode == TileType.Avatar || paintMode == TileType.Item) {
		paint_ctx.fillStyle = "rgb("+getPal(curPal())[2][0]+","+getPal(curPal())[2][1]+","+getPal(curPal())[2][2]+")";
	}

	//draw pixels
	for (var x = 0; x < 8; x++) {
		for (var y = 0; y < 8; y++) {
			// draw alternate frame
			if (isCurDrawingAnimated && curDrawingAltFrameData()[y][x] === 1) {
				paint_ctx.globalAlpha = 0.3;
				paint_ctx.fillRect(x*paint_scale,y*paint_scale,1*paint_scale,1*paint_scale);
				paint_ctx.globalAlpha = 1;
			}
			// draw current frame
			if (curDrawingData()[y][x] === 1) {
				paint_ctx.fillRect(x*paint_scale,y*paint_scale,1*paint_scale,1*paint_scale);
			}
		}
	}

	//draw grid
	if (drawPaintGrid) {
		paint_ctx.fillStyle = getContrastingColor();

		for (var x = 1; x < tilesize; x++) {
			paint_ctx.fillRect(x*paint_scale,0*paint_scale,1,tilesize*paint_scale);
		}
		for (var y = 1; y < tilesize; y++) {
			paint_ctx.fillRect(0*paint_scale,y*paint_scale,tilesize*paint_scale,1);
		}
	}
}

function curDrawingData() {
	var imgId = curDrawingImgId();
	// console.log(imgId);
	var frameIndex = (isCurDrawingAnimated ? curDrawingFrameIndex : 0);
	// console.log(imageStore.source[ imgId ]);
	return imageStore.source[ imgId ][ frameIndex ];
}

function curDrawingImgId() {
	var imgId = "";
	if( paint_paintMode == TileType.Tile )
		imgId += "TIL_";
	else if( paint_paintMode == TileType.Sprite || paint_paintMode == TileType.Avatar )
		imgId += "SPR_";
	else if( paint_paintMode == TileType.Item )
		imgId += "ITM_";
	imgId += paint_drawingId;
	return imgId;
}

function getContrastingColor(palId) {
	if (!palId) palId = curPal();
	var hsl = rgbToHsl( getPal(palId)[0][0], getPal(palId)[0][1], getPal(palId)[0][2] );
	// console.log(hsl);
	var lightness = hsl[2];
	if (lightness > 0.5) {
		return "#000";
	}
	else {
		return "#fff";
	}
}

function reloadTile() {
	// animation UI
	// if ( tile[drawingId] && tile[drawingId].animation.isAnimated ) {
	// 	isCurDrawingAnimated = true;
	// 	document.getElementById("animatedCheckbox").checked = true;

	// 	if( curDrawingFrameIndex == 0)
	// 	{
	// 		document.getElementById("animationKeyframe1").className = "animationThumbnail left selected";
	// 		document.getElementById("animationKeyframe2").className = "animationThumbnail right unselected";
	// 	}
	// 	else if( curDrawingFrameIndex == 1 )
	// 	{
	// 		document.getElementById("animationKeyframe1").className = "animationThumbnail left unselected";
	// 		document.getElementById("animationKeyframe2").className = "animationThumbnail right selected";
	// 	}

	// 	document.getElementById("animation").setAttribute("style","display:block;");
	// 	document.getElementById("animatedCheckboxIcon").innerHTML = "expand_more";
	// 	renderAnimationPreview( drawingId );
	// }
	// else {
	// 	isCurDrawingAnimated = false;
	// 	document.getElementById("animatedCheckbox").checked = false;
	// 	document.getElementById("animation").setAttribute("style","display:none;");
	// 	document.getElementById("animatedCheckboxIcon").innerHTML = "expand_less";
	// }

	// wall UI
	updateWallCheckboxOnCurrentTile();

	// updateDrawingNameUI(true);

	// drawPaintCanvas();
}

function updateWallCheckboxOnCurrentTile() {
	var isCurTileWall = false;

	if( tile[ paint_drawingId ].isWall == undefined || tile[ paint_drawingId ].isWall == null ) {
		if (room[curRoom]) {
			isCurTileWall = (room[curRoom].walls.indexOf(paint_drawingId) != -1);
		}
	}
	else {
		isCurTileWall = tile[ paint_drawingId ].isWall;
	}

	console.log("IS WALL " + isCurTileWall);

	if (isCurTileWall) {
		document.getElementById("wallCheckbox").checked = true;
		// document.getElementById("wallCheckboxIcon").innerHTML = "border_outer";
	}
	else {
		document.getElementById("wallCheckbox").checked = false;
		// document.getElementById("wallCheckboxIcon").innerHTML = "border_clear";
	}
}

function reloadSprite() {
	// // animation UI
	// if ( sprite[drawingId] && sprite[drawingId].animation.isAnimated ) {
	// 	isCurDrawingAnimated = true;
	// 	document.getElementById("animatedCheckbox").checked = true;

	// 	if( curDrawingFrameIndex == 0)
	// 	{
	// 		document.getElementById("animationKeyframe1").className = "animationThumbnail left selected";
	// 		document.getElementById("animationKeyframe2").className = "animationThumbnail right unselected";
	// 	}
	// 	else if( curDrawingFrameIndex == 1 )
	// 	{
	// 		document.getElementById("animationKeyframe1").className = "animationThumbnail left unselected";
	// 		document.getElementById("animationKeyframe2").className = "animationThumbnail right selected";
	// 	}

	// 	document.getElementById("animation").setAttribute("style","display:block;");
	// 	document.getElementById("animatedCheckboxIcon").innerHTML = "expand_more";
	// 	renderAnimationPreview( drawingId );
	// }
	// else {
	// 	isCurDrawingAnimated = false;
	// 	document.getElementById("animatedCheckbox").checked = false;
	// 	document.getElementById("animation").setAttribute("style","display:none;");
	// 	document.getElementById("animatedCheckboxIcon").innerHTML = "expand_less";
	// }

	// dialog UI
	reloadDialogUI()

	// updateDrawingNameUI( drawingId != "A" );

	// // update paint canvas
	// drawPaintCanvas();

}

function reloadDialogUI() {
	reloadDialogUICore();

	// reloadAdvDialogUI();
}

function reloadDialogUICore() { // TODO: name is terrible
	var dialogId = getCurDialogId();

	if (dialogId in dialog) {
		var dialogLines = dialog[dialogId].split("\n");
		if(dialogLines[0] === '"""') {
			// multi line
			var dialogStr = "";
			var i = 1;
			while (i < dialogLines.length && dialogLines[i] != '"""') {
				dialogStr += dialogLines[i] + (dialogLines[i+1] != '"""' ? '\n' : '');
				i++;
			}
			document.getElementById("dialogText").value = dialogStr;
		}
		else {
			// single line
			document.getElementById("dialogText").value = dialog[dialogId];
		}
	}
	else {
		document.getElementById("dialogText").value = "";
	}	
}

function getCurDialogId() {
	var dialogId = null;
	if(paint_paintMode == TileType.Sprite) {
		dialogId = sprite[paint_drawingId].dlg;
		if(dialogId == null && dialog[paint_drawingId] != null) {
			dialogId = paint_drawingId;
		}
	}
	else if(paint_paintMode == TileType.Item) {
		dialogId = item[paint_drawingId].dlg;
	}
	console.log("DIALOG ID " + dialogId);
	return dialogId;
}

function on_toggle_wall(e) {
	// if( tile[ drawingId ].isWall == undefined || tile[ drawingId ].isWall == null ) {
	// 	// clear out any existing wall settings for this tile in any rooms
	// 	// (this is back compat for old-style wall settings)
	// 	for( roomId in room ) {
	// 		var i = room[ roomId ].walls.indexOf( drawingId );
	// 		if( i > -1 )
	// 			room[ roomId ].walls.splice( i , 1 );
	// 	}
	// }

	if ( e.target.checked ){
		tile[ paint_drawingId ].isWall = true;
		// document.getElementById("wallCheckboxIcon").innerHTML = "border_outer";
	}
	else {
		tile[ paint_drawingId ].isWall = false;
		// document.getElementById("wallCheckboxIcon").innerHTML = "border_clear";
	}

	refreshGameData();
}

function on_change_dialog() {
	var dialogId = getCurDialogId();

	var dialogStr = document.getElementById("dialogText").value;
	if(dialogStr.length <= 0){
		if(dialogId) {
			getCurPaintObject().dlg = null;
			delete dialog[dialogId];
		}
	}
	else {
		if(!dialogId) {
			var prefix = (paint_paintMode == TileType.Item) ? "ITM_" : "SPR_";
			dialogId = nextAvailableDialogId( prefix );
			getCurPaintObject().dlg = dialogId;
		}
		if( dialogStr.indexOf('\n') > -1 ) dialogStr = '"""\n' + dialogStr + '\n"""';
		dialog[dialogId] = dialogStr;
	}

	// reloadAdvDialogUI();

	refreshGameData();
}

function getCurPaintObject(id) {
	if(id === undefined || id === null) id = paint_drawingId;
	console.log(id);
	if(paint_paintMode == TileType.Sprite || paint_paintMode == TileType.Avatar) {
		return sprite[id];
	}
	else if(paint_paintMode == TileType.Item) {
		return item[id];
	}
	else if(paint_paintMode == TileType.Tile) {
		return tile[id];
	}
}

function nextAvailableDialogId(prefix) {
	if(prefix === undefined || prefix === null) prefix = "";
	var i = 0;
	var id = prefix + i.toString(36);
	while( dialog[id] != null ) {
		i++;
		id = prefix + i.toString(36);
	}
	return id;
}

</script>

<style>
	html {
		height: 100%;
	}
	body {
		margin: 0 !important;
		padding: 0 !important;
		height: 100%;
	}

	body, input[type=text], button, select {
		font-size: 36px;
	}

	canvas {
		background: black;
		width: 100%;
		height: 100%;
		object-fit: contain;
	}

	.flexRoot {
		/*background: red;*/
		display: flex;
		flex-flow: column;
		height: 100%;
		width: 100%;
	}

	@media screen and (orientation: landscape) {
	  .flexRoot {
	    flex-direction: row;
	  }
	}

	@media screen and (orientation: portrait) {
	  .flexRoot {
	    flex-direction: column;
	  }
	}

	.flexMain {
		/*background: green;*/
		flex: 2;
		padding: 20px;
	}

	.flexAlt {
		/*background: blue;*/
		flex: 1;
		padding: 20px;
	}

	.responsiveRoot {
		height: 100%;
		width: 100%;
	}

	.responsiveMain {
		background: blue;
		/*display: inline-block;*/
		/*margin: 0;*/
		float:left;
	}
	.responsiveAlt {
		background: red;
		/*display: inline-block;*/
		/*margin: 0;*/
		float:right;
	}
	.innerGap {
		margin: 5%;
		width: 90%;
		height: 90%;
	}

	@media screen and (orientation: landscape) {
		.responsiveMain {
			width: 60%;
			height: 100%;
		}
		.responsiveAlt {
			width: 40%;
			height: 100%;
		}
	}

	@media screen and (orientation: portrait) {
		.responsiveMain {
			width: 100%;
			height: 60%;
		}
		.responsiveAlt {
			width: 100%;
			height: 40%;
		}
	}

	#game_data {
		width: calc(100% - 40px);
		height: 60%;
		margin: 20px;

		/*display: none;*/
		/*width: 100%;*/
		/*height: 200px;*/
	}

	.tool {
		width:100%;height:95%;margin:auto;
	}

	#colorPicker {
		/*background: red;*/
		width: 100%;
		height: 100%;
		/*position: relative;*/
	}

	#colorPickerWheelOuter {
		width: 100%;
		height: 80%;
		position: relative;
		background: black;
	}

	#colorPickerWheel, #colorPickerSelect {
		/*background: black;*/
		width: 100%;
		height: 100%;
		margin: 0px;
		position: absolute;
		top: 0px;
		left: 0px;
		object-fit: contain;
	}

	#colorPickerHexText {
		width: 70%;
		/*margin: 0px;*/
		margin: auto;
		margin-top: 10px;
	}

	#colorPickerSliderBg {
		width: calc(70% - 8px);
		margin-left: 15%;
		/*margin:auto;*/
	}

	#colorPaletteForm input[type=radio]:checked + label {
		border: solid 4px black;
		padding-top: 20px;
		padding-bottom: 20px;
	}

	#titleText, #dialogText {
		width: 600px;
		max-width: 80%;
	}
</style>

<body onload="start();">
	<div style="width: 100%;height: 5%; background:green; overflow:hidden;">
		<span style="float:left;">bitsy mobile alpha</span>

		<span style="float:right;">
			tool :
			<select id="tool_select" onchange="changeTool(event);">
				<option value="tool_room">room</option>
				<option value="tool_paint">paint</option>
				<option value="tool_color">color</option>
				<option value="tool_data">data</option>
			</select>
		</span>
	</div>
	<div id="tool_room" class="tool">
		<div class="responsiveRoot">
			<div class="responsiveMain">
				<div class="innerGap">
					<canvas id="game"></canvas>
				</div>
			</div>
			<div class="responsiveAlt">
				<div class="innerGap">
					<input type="checkbox" id="playModeCheck" onclick="togglePlayMode(event);" />
					<label title="play / pause game" for="playModeCheck">
						<!-- <i class="material-icons" id="playModeIcon">play_arrow</i> -->
						<span id="playModeText"> play </span>
					</label>

					<br/><br/>

					title : 
					<input title="title text for your game" type="text" id="titleText" onchange="on_change_title();" value="Write your game's title here" placeholder="Title">

					<br/><br/>

					<form>
						paint : 

						<input type="radio" name="room paint mode" value="avatar" onclick="on_room_paint_avatar();" id="room_paintOptionAvatar" checked>
						<label title="edit the avatar: the player's character" for="room_paintOptionAvatar" class="left">
							<!-- <i class="material-icons">perm_identity</i> -->
							avatar
						</label>

						<input type="radio" name="room paint mode" value="tile" onclick="on_room_paint_tile();" id="room_paintOptionTile">
						<label title="edit tiles: pieces of scenery" for="room_paintOptionTile" class="middle">
							<!-- <i class="material-icons">terrain</i> -->
							tile
						</label>

						<input type="radio" name="room paint mode" value="sprite" onclick="on_room_paint_sprite();" id="room_paintOptionSprite">
						<label title="edit sprites: non-player characters and interactive objects" for="room_paintOptionSprite" class="middle">
							<!-- <i class="material-icons">nature_people</i> -->
							sprite
						</label>
					</form>

					<select id="room_drawing_select" onchange="room_onSelectDrawing(event);" style="display: none;"></select>
				</div>
			</div>
		</div>
	</div>

	<div id="tool_paint" class="tool" style="display:none;">
		<div class="responsiveRoot">

			<div class="responsiveMain">
				<div class="innerGap">
					<canvas id="paint"></canvas>
				</div> <!-- innerGap -->
			</div> <!-- responsiveMain -->

			<div class="responsiveAlt">
				<div class="innerGap">

					<form>
						select drawing : 

						<input type="radio" name="paint mode" value="avatar" onclick="on_paint_avatar();" id="paintOptionAvatar" checked />
						<label title="edit the avatar: the player's character" for="paintOptionAvatar" class="left">
							<!-- <i class="material-icons">perm_identity</i> -->
							avatar
						</label>

						<input type="radio" name="paint mode" value="tile" onclick="on_paint_tile();" id="paintOptionTile" />
						<label title="edit tiles: pieces of scenery" for="paintOptionTile" class="middle">
							<!-- <i class="material-icons">terrain</i> -->
							tile
						</label>

						<input type="radio" name="paint mode" value="sprite" onclick="on_paint_sprite();" id="paintOptionSprite" />
						<label title="edit sprites: non-player characters and interactive objects" for="paintOptionSprite" class="middle">
							<!-- <i class="material-icons">nature_people</i> -->
							sprite
						</label>

						<select id="drawing_select" onchange="paint_onSelectDrawing(event);" style="display: none;"></select>
					</form>

					<div id="wall" style="display:none;">
						<input type="checkbox" id="wallCheckbox" onchange="on_toggle_wall(event);">
						<label title="make tile an impassible wall" for="wallCheckbox">
							<!-- <i id="wallCheckboxIcon" class="material-icons">border_clear</i> -->
							wall
						</label>
					</div>
					<div id="dialog" style="display:none;">
						<span style="/*float:left;*/">
							dialog
						</span>
						<textarea title="dialog text will be displayed when player approaches this sprite" id="dialogText" class="dialogTextArea" onkeydown="on_change_dialog();" onkeyup="on_change_dialog();" onchange="on_change_dialog();"></textarea>
					</div>

				</div> <!-- innerGap -->
			</div> <!-- responsiveMain -->

		</div> <!-- responsiveRoot -->
	</div>

	<div id="tool_color" class="tool" style="display:none;">
		<div class="responsiveRoot">
			<div class="responsiveMain">
				<div class="innerGap">
					<div id="colorPicker" title="color picker">
						<div id="colorPickerWheelOuter">
							<canvas id="colorPickerWheel"></canvas>
							<canvas id="colorPickerSelect" title="color picker wheel"></canvas>
						</div>
						<div id="colorPickerSliderBg" title="color picker darkness / lightness slider">
							<input type="range" id="colorPickerSlider" value="0" />
						</div>
						<input id="colorPickerHexText" title="color picker hex code" type="text" />
					</div>
				</div>
			</div>
			<div class="responsiveAlt">
				<div class="innerGap">
					<form id="colorPaletteForm">
						<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionBackground" onclick="changeColorPickerIndex(0);" checked />
						<label id="colorPaletteLabelBackground" for="colorPaletteOptionBackground" title="pick background color">
							<!-- <i class="material-icons">grid_on</i> -->
							background color
						</label>

						<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionTile" onclick="changeColorPickerIndex(1);" />
						<label id="colorPaletteLabelTile" for="colorPaletteOptionTile" title="pick tile color">
							<!-- <i class="material-icons">terrain</i> -->
							tile color
						</label>

						<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionSprite" onclick="changeColorPickerIndex(2);" />
						<label id="colorPaletteLabelSprite" for="colorPaletteOptionSprite" title="pick sprite / avatar / item color">
							<!-- <i class="material-icons">nature_people</i> -->
							sprite color
						</label>
					</form>
				</div>
			</div>
		</div>
	</div>
	<div id="tool_data" class="tool" style="display:none;">
		<button title="reset everything and start new game" class="color0" onclick="newGameDialog();">
			<!-- <i class="material-icons">restore_page</i> -->
			reset game data
		</button>
		<textarea id="game_data" onchange="editGameData();"></textarea>
	</div>
</body>

<script type="bitsyGameData" id="defaultGameData">
Write your game's title here

# BITSY VERSION 4.6

! ROOM_FORMAT 1

PAL 0
0,82,204
128,159,255
255,255,255

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PAL 0

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111

SPR A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
POS 0 4,4

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
DLG SPR_0
POS 0 8,12

ITM 0
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea
DLG ITM_0

DLG SPR_0
I'm a cat

DLG ITM_0
You found a nice warm cup of tea

VAR a
42
</script>

</html>