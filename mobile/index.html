<!DOCTYPE HTML>
<html>

<head>
	<title>bitsy mobile alpha</title>
</head>

<!-- STYLES -->
<link rel="stylesheet" type="text/css" href="../src/style/colorPickerStyle.css">

<!-- UTIL SCRIPTS -->
<script src="../src/script/color_util.js"></script>

<!-- ENGINE SCRIPTS -->
<script src="../src/script/font.js"></script>
<script src="../src/script/script.js"></script>
<script src="../src/script/dialog.js"></script>
<script src="../src/script/bitsy.js"></script>

<!-- NEW EDITOR SCRIPTS (WIP) -->
<script src="../src/script/editor/core.js"></script>
<script src="../src/script/editor/paint.js"></script>
<script src="../src/script/editor/room.js"></script>

<!-- EDITOR SCRIPTS -->
<script src="../src/script/color_picker.js"></script>

<script>
/*
GOALS
- mobile friendly UI
- bitsy v0.1 functionality
- better componentized code

IDEAS
- tools are one page each
- tools are **self contained**
- swipe to navigate tools?
- horizontal vs vertical mode
- zoom?
- how do you handle exporting games?

TODO
X game canvas
X game data
X play / pause
X resize to fit phone
X host somewhere
X title
X select tile / avatar / sprite
X edit map
X paint panel
	X dialog
	X wall
	X add
	X delete
X fix layout issues
- zoom
X figure out localhost -> mobile dev cycle
X fix color picker
- fix color slider [maybe I did??]
X font size issue (currently fixed by making it big?)
- try flex panel again
- try making a game!!
- what is the correct way to handle font sizing??

BUGS
X can't drag to delete tiles
X drag also moves player
X sprite / tile select doesn't update on add / delete
X tile add / delete doesn't seem to work right?
X add / delete shouldn't be visible on avatar

Random thoughts
- title on EVERY room?
- how to distinguish between mobile / desktop tool versions?
- can we collapse distinction between different drawing types? avatar / sprite / tile / item
- SFX?
- tools as iframes?
- need a color palette preview of tiles / sprites
- dropdown box sucks as a way to switch between tools

Components:
- room tool
- paint tool
- color picker (done-ish)
- drawing selector
- data panel

Shared code plan:
- sort code in prototype by tool / category
- pull out shared functions
- platform specialization
- componetization? (data-oriented or object-oriented? or?)
- also: componentize parser code

BUG: convert â€™ -> ' in dialog

DEV NOTES:
- debug with safari
	- host on localhost with: python -m SimpleHTTPServer
		- run from project root
	- connect on iphone via: ip.address:8000/mobile
*/

/*
	CORE
*/

// shared
function start() {
	Ed().platform = PlatformType.Mobile;

	attachCanvas( document.getElementById("game") );

	roomTool = new RoomTool(canvas);
	paintTool = new PaintTool(document.getElementById("paint"),roomTool);
	paintTool.onReloadTile = function(){ reloadTile() };
	paintTool.onReloadSprite = function(){ reloadSprite() };

	//load last auto-save
	if (localStorage.game_data) {
		document.getElementById("game_data").value = localStorage.game_data;
	}
	else {
		setDefaultGameState();
	}

	initGameState();
	// initGameStateAndRender(); // also parses and loads the data --- needs to be two separate things

	// console.log("title : " + title);

	document.getElementById("titleText").value = title;

	paintTool.updateCanvas();

	// init color picker
	colorPicker = new ColorPicker('colorPickerWheel', 'colorPickerSelect', 'colorPickerSlider', 'colorPickerSliderBg', 'colorPickerHexText');
	colorPicker.onColorChange = onColorPickerChange;
	document.getElementById("colorPaletteOptionBackground").checked = true;
	updateColorPickerUI();

	document.getElementById("playModeCheck").checked = false;
	document.getElementById("tool_select").options[0].selected = true;

	roomTool.drawEditMap();

	roomTool.listenEditEvents();
}

// mobile
function initGameState() {
	// re-import game data into the engine
	clearGameData();
	parseWorld(document.getElementById("game_data").value);
	renderImages();
}

// mobile
function initGameStateAndRender() {
	initGameState();
	roomTool.drawEditMap();
}

// mobile
function changeTool(e) {
	Array.from( document.getElementsByClassName("tool") ).map( function(t) { t.style.display = "none"; } );
	document.getElementById(e.target.value).style.display = "block";
}

/* 
	ROOM
*/
var roomTool;

// shared
function on_play_mode() {
	roomTool.unlistenEditEvents();
	load_game(document.getElementById("game_data").value);
}

// shared
function on_edit_mode() {
	stopGame();
	parseWorld(document.getElementById("game_data").value);
	roomTool.listenEditEvents();
	roomTool.drawEditMap();
	// initGameStateAndRender();
}

// shared
// TODO: these need to be specialized for ROOM and PAINT tools
function on_room_paint_avatar() {
	roomTool.drawing.type = TileType.Avatar;
	roomTool.drawing.id = "A";

	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "none";
}

function on_room_paint_tile() {
	roomTool.drawing.type = TileType.Tile;
	tileIndex = 0;
	roomTool.drawing.id = sortedTileIdList()[tileIndex];

	// update options
	var selectDrawing = document.getElementById("room_drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedTileIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];
		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}
}

function on_room_paint_sprite() {
	roomTool.drawing.type = TileType.Sprite;
	if (sortedSpriteIdList().length > 1)
	{
		spriteIndex = 1;
	}
	else {
		spriteIndex = 0; //fall back to avatar if no other sprites exist
	}
	roomTool.drawing.id = sortedSpriteIdList()[spriteIndex];

	// update options
	var selectDrawing = document.getElementById("room_drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedSpriteIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];

		if(id === "A")
			continue;

		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}
}

// mobile
function room_onSelectDrawing(e) {
	roomTool.drawing.id = e.target.value;
}


/* 
	PAINT 
*/
var paintTool;

function on_paint_avatar() {
	paintTool.drawing.type = TileType.Avatar;
	paintTool.drawing.id = "A";

	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "none";

	paintTool.updateCanvas();

	document.getElementById("dialog").setAttribute("style","display:none;");
	document.getElementById("wall").setAttribute("style","display:none;");
	document.getElementById("paintCommands").setAttribute("style","display:none;");
}

function on_paint_tile() {
	paintTool.drawing.type = TileType.Tile;
	paintTool.drawing.id = sortedTileIdList()[0];

	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedTileIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];
		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}

	reloadTile();
	paintTool.updateCanvas();

	document.getElementById("dialog").setAttribute("style","display:none;");
	document.getElementById("wall").setAttribute("style","display:block;");
	document.getElementById("paintCommands").setAttribute("style","display:block;");
}

function on_paint_sprite() {
	paintTool.drawing.type = TileType.Sprite;
	paintTool.drawing.id = sortedSpriteIdList()[sortedSpriteIdList().length > 1 ? 1 : 0];

	// update options
	var selectDrawing = document.getElementById("drawing_select");
	selectDrawing.style.display = "inline";
	for(var i = selectDrawing.options.length - 1 ; i >= 0 ; i--) {
		selectDrawing.remove(i);
	}
	var idList = sortedSpriteIdList();
	for(var i = 0; i < idList.length; i++) {
		var id = idList[i];

		if(id === "A")
			continue;

		var option = document.createElement("option");
		option.text = id;
		option.value = id;
		selectDrawing.add(option);
	}

	reloadSprite();

	paintTool.updateCanvas();

	document.getElementById("dialog").setAttribute("style","display:block;");
	document.getElementById("wall").setAttribute("style","display:none;");
	document.getElementById("paintCommands").setAttribute("style","display:block;");
}

function paint_onSelectDrawing(e) {
	paintTool.drawing.id = e.target.value;
	paintTool.updateCanvas();

	// TODO : make these functions less hacky and terrible
	if(paintTool.drawing.type == TileType.Tile) {
		reloadTile();
	}
	else if(paintTool.drawing.type == TileType.Sprite) {
		reloadSprite();
	}
}

// specialized
function reloadTile() {
	updateWallCheckboxOnCurrentTile();
}

// specialized - sort of
function updateWallCheckboxOnCurrentTile() {
	var isCurTileWall = false;

	if( tile[ paintTool.drawing.id ].isWall == undefined || tile[ paintTool.drawing.id ].isWall == null ) {
		if (room[curRoom]) {
			isCurTileWall = (room[curRoom].walls.indexOf(paintTool.drawing.id) != -1);
		}
	}
	else {
		isCurTileWall = tile[ paintTool.drawing.id ].isWall;
	}

	console.log("IS WALL " + isCurTileWall);

	if (isCurTileWall) {
		document.getElementById("wallCheckbox").checked = true;
		// document.getElementById("wallCheckboxIcon").innerHTML = "border_outer";
	}
	else {
		document.getElementById("wallCheckbox").checked = false;
		// document.getElementById("wallCheckboxIcon").innerHTML = "border_clear";
	}
}

// specialized
function reloadSprite() {
	reloadDialogUI()
}

// specialized - sort of
function on_toggle_wall(e) {
	paintTool.toggleWall( e.target.checked );
}

// specialized - sort of
function newDrawing() {
	paintTool.newDrawing();
}

// shared
function deleteDrawing() {
	// if ( confirm("Are you sure you want to delete this drawing?") ) {
		// deletePaintThumbnail( roomTool.drawing.id );
		if (roomTool.drawing.type == TileType.Tile) {
			if ( Object.keys( tile ).length <= 1 ) { /*alert("You can't delete your last tile!");*/ return; }
			delete tile[ paintTool.drawing.id ];
			findAndReplaceTileInAllRooms( paintTool.drawing.id, "0" );
			refreshGameData();
			renderImages();
			roomTool.drawEditMap();
			// nextTile();
			on_paint_tile();
		}
		else if( roomTool.drawing.type == TileType.Avatar || roomTool.drawing.type == TileType.Sprite ){
			if ( Object.keys( sprite ).length <= 2 ) { /*alert("You can't delete your last sprite!");*/ return; }

			// todo: share with items
			var dlgId = sprite[ paintTool.drawing.id ].dlg == null ? paintTool.drawing.id : sprite[ paintTool.drawing.id ].dlg;
			if( dlgId && dialog[ dlgId ] )
				delete dialog[ dlgId ];

			delete sprite[ paintTool.drawing.id ];

			refreshGameData();
			renderImages();
			roomTool.drawEditMap();
			// nextSprite();
			on_paint_sprite();
		}
		// else if( roomTool.drawing.type == TileType.Item ){
		// 	if ( Object.keys( item ).length <= 1 ) { alert("You can't delete your last item!"); return; }

		// 	var dlgId = item[ roomTool.drawing.id ].dlg;
		// 	if( dlgId && dialog[ dlgId ] )
		// 		delete dialog[ dlgId ];

		// 	delete item[ roomTool.drawing.id ];

		// 	removeAllItems( roomTool.drawing.id );
		// 	refreshGameData();
		// 	renderImages();
		// 	roomTool.drawEditMap();
		// 	nextItem();
		// 	updateInventoryItemUI();
		// }
		// changePaintExplorerSelection( roomTool.drawing.id );
	// }
}


/* 
	COLOR 
*/
var colorPicker = null; // new color picker
var colorPickerIndex = 0;
var colorPaletteLabels = ["colorPaletteLabelBackground", "colorPaletteLabelTile", "colorPaletteLabelSprite"];

function changeColorPickerIndex(index) {
	colorPickerIndex = index;
	var color = getPal(selectedColorPal())[ index ];
	console.log(color);
	colorPicker.setColor( color[0], color[1], color[2] );
}

function updateColorPickerLabel(index, r, g, b) {
	var rgbColor = {r:r, g:g, b:b};

	var rgbColorStr = "rgb(" + rgbColor.r + "," + rgbColor.g + "," + rgbColor.b + ")";
	var hsvColor = RGBtoHSV( rgbColor );
	document.getElementById( colorPaletteLabels[ index ] ).style.background = rgbColorStr;
	document.getElementById( colorPaletteLabels[ index ] ).style.color = hsvColor.v < 0.5 ? "white" : "black";
}

function onColorPickerChange( rgbColor, isMouseUp ) {
	getPal(selectedColorPal())[ colorPickerIndex ][ 0 ] = rgbColor.r;
	getPal(selectedColorPal())[ colorPickerIndex ][ 1 ] = rgbColor.g;
	getPal(selectedColorPal())[ colorPickerIndex ][ 2 ] = rgbColor.b;

	updateColorPickerLabel(colorPickerIndex, rgbColor.r, rgbColor.g, rgbColor.b );

	if( isMouseUp ) {
		// refreshGameData();
		// renderImages();
		// paintTool.updateCanvas();
		// roomTool.drawEditMap();
		// refreshPaintExplorer( true /*doKeepOldThumbnails*/ );
		// if( isCurDrawingAnimated )
		// 	renderAnimationPreview( roomTool.drawing.id );

		refreshGameData();
		initGameStateAndRender();
	}
}

function updateColorPickerUI() {
	var color0 = getPal(selectedColorPal())[ 0 ];
	var color1 = getPal(selectedColorPal())[ 1 ];
	var color2 = getPal(selectedColorPal())[ 2 ];

	updateColorPickerLabel(0, color0[0], color0[1], color0[2] );
	updateColorPickerLabel(1, color1[0], color1[1], color1[2] );
	updateColorPickerLabel(2, color2[0], color2[1], color2[2] );

	changeColorPickerIndex( colorPickerIndex );
}


/* 
	DATA 
*/
function editGameData() {
	initGameStateAndRender();
	localStorage.game_data = document.getElementById("game_data").value;
}

function refreshGameData() {
	// if (isPlayMode) return; //never store game data while in playmode (TODO: wouldn't be necessary if the game data was decoupled form editor data)

	flags.ROOM_FORMAT = 1; // always save out comma separated format, even if the old format is read in
	var gameData = serializeWorld();
	//console.log("refresh!");
	//console.log(gameData);
	document.getElementById("game_data").value = gameData;
	localStorage.setItem("game_data", gameData); //auto-save
}

function newGameDialog() {
	// if ( confirm("Starting a new game will erase your old data. Consider exporting your work first! Are you sure you want to start over?") ) {
		resetGameData();
	// }
}

function resetGameData() {
	setDefaultGameState();

	// // todo wrap these variable resets in a function
	// tileIndex = 0;
	// spriteIndex = 0;

	// refreshGameData();
	// renderImages();
	// paintTool.updateCanvas();
	// roomTool.drawEditMap();
	// updatePaletteUI();
	// // updatePaletteControlsFromGameData();
	// updateExitOptionsFromGameData();
	// updateRoomName();
	// updateInventoryUI();

	// on_paint_avatar();
	// document.getElementById('paintOptionAvatar').checked = true;

	initGameStateAndRender();
	updateColorPickerUI();
}

function setDefaultGameState() {
	// trying new way to get default game data
	document.getElementById("game_data").value = document.getElementById("defaultGameData").text.slice(1);
	localStorage.game_data = document.getElementById("game_data").value;
}


</script>

<style>
	html {
		height: 100%;
	}
	body {
		margin: 0 !important;
		padding: 0 !important;
		height: 100%;
	}

	body, input[type=text], button, select {
		font-size: 36px;
	}

	canvas {
		background: black;
		width: 100%;
		height: 100%;
		object-fit: contain;
	}

	.flexRoot {
		/*background: red;*/
		display: flex;
		flex-flow: column;
		height: 100%;
		width: 100%;
	}

	@media screen and (orientation: landscape) {
	  .flexRoot {
	    flex-direction: row;
	  }
	}

	@media screen and (orientation: portrait) {
	  .flexRoot {
	    flex-direction: column;
	  }
	}

	.flexMain {
		background: yellow;
		/*flex-grow: 2;*/
		/*flex-shrink: 1;*/
		/*flex-basis: 40%;*/
		/*height: 512px;*/
		/*width: 512px;*/
		padding: 20px;
	}

	.flexAlt {
		background: purple;
		/*flex-grow: 1;*/
		/*flex-shrink: 2;*/
		/*flex-basis: 30%;*/
		padding: 20px;
	}

	.responsiveRoot {
		height: 100%;
		width: 100%;
	}

	.responsiveMain {
		background: blue;
		/*display: inline-block;*/
		/*margin: 0;*/
		float:left;
	}
	.responsiveAlt {
		background: red;
		/*display: inline-block;*/
		/*margin: 0;*/
		float:right;
	}

	.innerGap {
		margin: 2%;
		width: 96%;
		height: 96%;
	}

	@media screen and (orientation: landscape) {
		.responsiveMain {
			width: 50%;
			height: 100%;
		}
		.responsiveAlt {
			width: 50%;
			height: 100%;
		}
	}

	@media screen and (orientation: portrait) {
		.responsiveMain {
			width: 100%;
			height: 70%;
		}
		.responsiveAlt {
			width: 100%;
			height: 30%;
		}
	}

	#game_data {
		width: calc(100% - 40px);
		height: 60%;
		margin: 20px;

		/*display: none;*/
		/*width: 100%;*/
		/*height: 200px;*/
	}

	.tool {
		width:100%;height:100%;margin:auto;
	}

	#colorPicker {
		/*background: red;*/
		width: 100%;
		height: 100%;
		/*position: relative;*/
	}

	#colorPickerWheelOuter {
		width: 100%;
		height: 80%;
		position: relative;
		background: black;
	}

	#colorPickerWheel, #colorPickerSelect {
		/*background: black;*/
		width: 100%;
		height: 100%;
		margin: 0px;
		position: absolute;
		top: 0px;
		left: 0px;
		object-fit: contain;
	}

	#colorPickerHexText {
		width: 70%;
		/*margin: 0px;*/
		margin: auto;
		margin-top: 10px;
	}

	#colorPickerSliderBg {
		width: calc(70% - 8px);
		margin-left: 12%;
		/*margin:auto;*/
	}

	#colorPaletteForm input[type=radio]:checked + label {
		border: solid 4px black;
		padding-top: 20px;
		padding-bottom: 20px;
	}

	#titleText, #dialogText {
		width: 600px;
		max-width: 80%;
	}

	/* custom slider thumb */
	#colorPickerSlider::-webkit-slider-thumb {
		-webkit-appearance: none;
		border: 4px solid #000000;
		height: 36px;
		width: 36px;
		border-radius: 18px;
		background: #ffffff;
		cursor: pointer;
		margin-top: -12px;
	}

	/* custom slider track */
	#colorPickerSlider::-webkit-slider-runnable-track {
		width: 100%;
		height: 8px;
		cursor: pointer;
		background: #fff;
		margin-top: -28px;
	}

	#colorPickerSliderBg {
		padding: 30px;
		border-radius: 8px;
	}
</style>

<body onload="start();">
	<div style="display: flex; flex-flow: column; height: 100%; width: 100%;">

	<!-- <div style="width: 100%;height: 5%; background:green; overflow:hidden;"> -->
	<div style="flex:1 1 5%;">

		<span style="float:left;">bitsy mobile alpha</span>

		<span style="float:right;">
			tool :
			<select id="tool_select" onchange="changeTool(event);">
				<option value="tool_room">room</option>
				<option value="tool_paint">paint</option>
				<option value="tool_color">color</option>
				<option value="tool_data">data</option>
			</select>
		</span>

	</div>

	<div style="flex:1 1 95%; min-width: 0; min-height: 0;">

	<div id="tool_room" class="tool">
		<!-- <div class="flexRoot"> -->
		<div class="responsiveRoot">
			<!-- <div class="flexMain"> -->
			<div class="responsiveMain">
				<div class="innerGap">
					<canvas id="game"></canvas>
				</div>
			</div>
			<!-- </div> -->
			<!-- <div class="flexAlt"> -->
			<div class="responsiveAlt">
				<div class="innerGap">
					<input type="checkbox" id="playModeCheck" onclick="togglePlayMode(event);" />
					<label title="play / pause game" for="playModeCheck">
						<!-- <i class="material-icons" id="playModeIcon">play_arrow</i> -->
						<span id="playModeText"> play </span>
					</label>

					<br/><br/>

					title : 
					<input title="title text for your game" type="text" id="titleText" onchange="on_change_title(event);" value="Write your game's title here" placeholder="Title">

					<br/><br/>

					<form>
						paint : 

						<input type="radio" name="room paint mode" value="avatar" onclick="on_room_paint_avatar();" id="room_paintOptionAvatar" checked>
						<label title="edit the avatar: the player's character" for="room_paintOptionAvatar" class="left">
							<!-- <i class="material-icons">perm_identity</i> -->
							avatar
						</label>

						<input type="radio" name="room paint mode" value="tile" onclick="on_room_paint_tile();" id="room_paintOptionTile">
						<label title="edit tiles: pieces of scenery" for="room_paintOptionTile" class="middle">
							<!-- <i class="material-icons">terrain</i> -->
							tile
						</label>

						<input type="radio" name="room paint mode" value="sprite" onclick="on_room_paint_sprite();" id="room_paintOptionSprite">
						<label title="edit sprites: non-player characters and interactive objects" for="room_paintOptionSprite" class="middle">
							<!-- <i class="material-icons">nature_people</i> -->
							sprite
						</label>
					</form>

					<select id="room_drawing_select" onchange="room_onSelectDrawing(event);" style="display: none;"></select>
				</div>
			</div>
			<!-- </div> -->
		</div>
		<!-- </div> -->
	</div>

	<div id="tool_paint" class="tool" style="display:none;">
		<div class="responsiveRoot">

			<div class="responsiveMain">
				<div class="innerGap">
					<canvas id="paint"></canvas>
				</div> <!-- innerGap -->
			</div> <!-- responsiveMain -->

			<div class="responsiveAlt">
				<div class="innerGap">

					<form>
						select drawing : 

						<input type="radio" name="paint mode" value="avatar" onclick="on_paint_avatar();" id="paintOptionAvatar" checked />
						<label title="edit the avatar: the player's character" for="paintOptionAvatar" class="left">
							<!-- <i class="material-icons">perm_identity</i> -->
							avatar
						</label>

						<input type="radio" name="paint mode" value="tile" onclick="on_paint_tile();" id="paintOptionTile" />
						<label title="edit tiles: pieces of scenery" for="paintOptionTile" class="middle">
							<!-- <i class="material-icons">terrain</i> -->
							tile
						</label>

						<input type="radio" name="paint mode" value="sprite" onclick="on_paint_sprite();" id="paintOptionSprite" />
						<label title="edit sprites: non-player characters and interactive objects" for="paintOptionSprite" class="middle">
							<!-- <i class="material-icons">nature_people</i> -->
							sprite
						</label>
					</form>

					<select id="drawing_select" onchange="paint_onSelectDrawing(event);" style="display: none;"></select>

					<div id="paintCommands" class="buttonGroup" style="display:none;">
						<button title="add drawing" class="color0" onclick="newDrawing();">
							<!-- <i class="material-icons">add</i> -->
							+ add
						<!-- </button>
						<button title="duplicate drawing" class="color0" onclick="duplicateDrawing();">
							<i class="material-icons">content_copy</i>
						</button> -->
						<button title="delete drawing" class="color0" onclick="deleteDrawing();">
							<!-- <i class="material-icons">remove_circle</i> -->
							- delete
						</button>
					</div>

					<div id="wall" style="display:none;">
						<input type="checkbox" id="wallCheckbox" onchange="on_toggle_wall(event);">
						<label title="make tile an impassible wall" for="wallCheckbox">
							<!-- <i id="wallCheckboxIcon" class="material-icons">border_clear</i> -->
							wall
						</label>
					</div>
					<div id="dialog" style="display:none;">
						<span style="/*float:left;*/">
							dialog
						</span>
						<textarea title="dialog text will be displayed when player approaches this sprite" id="dialogText" class="dialogTextArea" onkeydown="on_change_dialog();" onkeyup="on_change_dialog();" onchange="on_change_dialog();"></textarea>
					</div>

				</div> <!-- innerGap -->
			</div> <!-- responsiveMain -->

		</div> <!-- responsiveRoot -->
	</div>

	<div id="tool_color" class="tool" style="display:none;">
		<div class="responsiveRoot">
			<div class="responsiveMain">
				<div class="innerGap">
					<div id="colorPicker" title="color picker">
						<div id="colorPickerWheelOuter">
							<canvas id="colorPickerWheel"></canvas>
							<canvas id="colorPickerSelect" title="color picker wheel"></canvas>
						</div>
						<div id="colorPickerSliderBg" title="color picker darkness / lightness slider">
							<input type="range" id="colorPickerSlider" value="0" />
						</div>
						<input id="colorPickerHexText" title="color picker hex code" type="text" />
					</div>
				</div>
			</div>
			<div class="responsiveAlt">
				<div class="innerGap">
					<form id="colorPaletteForm">
						<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionBackground" onclick="changeColorPickerIndex(0);" checked />
						<label id="colorPaletteLabelBackground" for="colorPaletteOptionBackground" title="pick background color">
							<!-- <i class="material-icons">grid_on</i> -->
							background color
						</label>

						<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionTile" onclick="changeColorPickerIndex(1);" />
						<label id="colorPaletteLabelTile" for="colorPaletteOptionTile" title="pick tile color">
							<!-- <i class="material-icons">terrain</i> -->
							tile color
						</label>

						<input type="radio" name="colorPalette" value="background" id="colorPaletteOptionSprite" onclick="changeColorPickerIndex(2);" />
						<label id="colorPaletteLabelSprite" for="colorPaletteOptionSprite" title="pick sprite / avatar / item color">
							<!-- <i class="material-icons">nature_people</i> -->
							sprite color
						</label>
					</form>
				</div>
			</div>
		</div>
	</div>
	<div id="tool_data" class="tool" style="display:none;">
		<button title="reset everything and start new game" class="color0" onclick="newGameDialog();">
			<!-- <i class="material-icons">restore_page</i> -->
			reset game data
		</button>
		<textarea id="game_data" onchange="editGameData();"></textarea>
	</div>

	</div>

	</div>
</body>

<script type="bitsyGameData" id="defaultGameData">
Write your game's title here

# BITSY VERSION 4.6

! ROOM_FORMAT 1

PAL 0
0,82,204
128,159,255
255,255,255

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PAL 0

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111

SPR A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
POS 0 4,4

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
DLG SPR_0
POS 0 8,12

ITM 0
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea
DLG ITM_0

DLG SPR_0
I'm a cat

DLG ITM_0
You found a nice warm cup of tea

VAR a
42
</script>

</html>