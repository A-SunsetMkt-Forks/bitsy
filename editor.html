<!DOCTYPE HTML>
<html>
	<head>
		<title>bitsy editor</title>

		<style>
			body {
				/*color:#fff*/
				background: #ffb3d9; /*#ccccff*/
				line-height: 150%;
			}
			canvas {
				background: black;
			}
			#topbar {
				width: 100%;
			}
			.panel {
				float:left;
				background: white;
				/*height: 600px;*/
				margin:10px;
				padding: 10px;
			}
			#game {
				/*
				width: 512px;
				height: 512px;
				*/
			}
			#paint {
				/*
				width: 256px;
				height: 256px;
				*/
			}
		</style>

		<script src="bitsy.js"></script>
		<script>
			/* MOES */
			var TileType = {
				Tile : 0,
				Sprite : 1,
				Avatar : 2
			};
			var EditMode = {
				Edit : 0,
				Play : 1
			};

			var editMode = EditMode.Edit;

			/* PAINT */
			var paint_canvas;
			var paint_ctx;
			var paint_scale = 32;

			var paintMode = TileType.Avatar;
			var drawingId = "A";
			var drawingPal = "0";
			var drawing_data = [
				[0,0,0,0,0,0,0,0],
				[0,0,0,0,0,0,0,0],
				[0,0,0,0,0,0,0,0],
				[0,0,0,0,0,0,0,0],
				[0,0,0,0,0,0,0,0],
				[0,0,0,0,0,0,0,0],
				[0,0,0,0,0,0,0,0],
				[0,0,0,0,0,0,0,0]
			];
			var drawPaintGrid = true;
			var curPaintBrush = 0;
			var isPainting = false;

			var nextTileCharCode = 97;
			var tileIndex = 0;

			/* MAP */
			var drawMapGrid = true;

			function start() {
				//game canvas & context (also the map editor)
				canvas = document.getElementById("game");
				canvas.width = width * scale;
				canvas.height = width * scale;
				ctx = canvas.getContext("2d");
				//map edit events
				listenMapEditEvents();

				//paint canvas & context
				paint_canvas = document.getElementById("paint");
				paint_canvas.width = tilesize * paint_scale;
				paint_canvas.height = tilesize * paint_scale;
				paint_ctx = paint_canvas.getContext("2d");
				//paint events
				paint_canvas.addEventListener("mousedown", paint_onMouseDown);
				paint_canvas.addEventListener("mousemove", paint_onMouseMove);
				paint_canvas.addEventListener("mouseup", paint_onMouseUp);
				paint_canvas.addEventListener("mouseleave", paint_onMouseUp);


				//default values
				title = "Write title here";
				palette[drawingPal] = [
					[0,82,204],
					[128,159,255],
					[255,255,255]
				];
				//default avatar
				paintMode = TileType.Avatar;
				on_paint_avatar();
				drawing_data = [
					[0,0,0,1,1,0,0,0],
					[0,0,0,1,1,0,0,0],
					[0,0,0,1,1,0,0,0],
					[0,0,1,1,1,1,0,0],
					[0,1,1,1,1,1,1,0],
					[1,0,1,1,1,1,0,1],
					[0,0,1,0,0,1,0,0],
					[0,0,1,0,0,1,0,0]
				];
				saveDrawingData();
				sprite["A"].set = "0";
				sprite["A"].x = 4;
				sprite["A"].y = 4;
				//defualt sprite todo
				paintMode = TileType.Tile;
				newTile();
				on_paint_tile();
				console.log(drawingId);
				drawing_data = [
					[1,1,1,1,1,1,1,1],
					[1,0,0,0,0,0,0,1],
					[1,0,0,0,0,0,0,1],
					[1,0,0,1,1,0,0,1],
					[1,0,0,1,1,0,0,1],
					[1,0,0,0,0,0,0,1],
					[1,0,0,0,0,0,0,1],
					[1,1,1,1,1,1,1,1]
				];
				saveDrawingData();
				//default tile
				renderImages();
				//default set
				set["0"] = {
					id : "0",
					tilemap : [
							"0000000000000000",
							"0aaaaaaaaaaaaaa0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0a000000000000a0",
							"0aaaaaaaaaaaaaa0",
							"0000000000000000"
						],
					walls : [],
					exits : [],
					pal : null
				};
				refreshGameData();

				//draw everything
				drawPaintCanvas();
				drawEditMap();
			}

			function listenMapEditEvents() {
				canvas.addEventListener("mousedown", map_onMouseDown);
			}

			function unlistenMapEditEvents() {
				canvas.removeEventListener("mousedown", map_onMouseDown);
			}

			function newTile() {
				drawingId = String.fromCharCode( nextTileCharCode );
				nextTileCharCode++;

				drawing_data = [
					[0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0]
				];

				drawPaintCanvas();
				saveDrawingData();
				refreshGameData();

				tileIndex = Object.keys(tile).length - 1;
			}

			function nextTile() {
				var ids = sortedTileIdList();
				tileIndex = (tileIndex + 1) % ids.length;
				drawingId = ids[tileIndex];
				reloadTile();
			}

			function prevTile() {
				var ids = sortedTileIdList();
				tileIndex = (tileIndex - 1) % ids.length;
				if (tileIndex < 0) tileIndex = (ids.length-1);
				drawingId = ids[tileIndex];
				reloadTile();
			}

			function reloadTile() {
				var drw = "TIL_" + drawingId;
				for (y in imageStore.source[drw]) {
					for (var x = 0; x < 8; x++) {
						var pixel = parseInt( imageStore.source[drw][y].charAt(x) );
						drawing_data[y][x] = pixel;
					}
				}
				drawPaintCanvas();
			}

			function reloadSprite() {
				var drw = "SPR_" + drawingId;
				for (y in imageStore.source[drw]) {
					for (var x = 0; x < 8; x++) {
						var pixel = parseInt( imageStore.source[drw][y].charAt(x) );
						drawing_data[y][x] = pixel;
					}
				}
				drawPaintCanvas();
			}

			function sortedTileIdList() {
				return Object.keys( tile ).sort();
			}

			function sortedSpriteIdList() {
				return Object.keys( sprite ).sort();
			}

			function map_onMouseDown(e) {
				var x = Math.floor(e.layerX / (tilesize*scale));
				var y = Math.floor(e.layerY / (tilesize*scale));
				console.log(x + " " + y);
				var row = set[curSet].tilemap[y];
				if (drawingId != null) {
					if (paintMode == TileType.Tile) {
						if ( row.charAt(x) === "0" ) {
							//add
							row = row.substr(0, x) + drawingId + row.substr(x+1);
						}
						else {
							//delete (better way to do this?)
							row = row.substr(0, x) + "0" + row.substr(x+1);
						}
						set[curSet].tilemap[y] = row;
					}
					else {
						sprite[drawingId].set = curSet;
						sprite[drawingId].x = x;
						sprite[drawingId].y = y;
						row = row.substr(0, x) + "0" + row.substr(x+1);
					}
					refreshGameData();
					drawEditMap();
				}
			}

			function paint_onMouseDown(e) {
				var x = Math.floor(e.layerX / paint_scale);
				var y = Math.floor(e.layerY / paint_scale);
				if (drawing_data[y][x] == 0) {
					curPaintBrush = 1;
				}
				else {
					curPaintBrush = 0;
				}
				drawing_data[y][x] = curPaintBrush;
				drawPaintCanvas();
				isPainting = true;
			}

			function paint_onMouseMove(e) {
				if (isPainting) {	
					var x = Math.floor(e.layerX / paint_scale);
					var y = Math.floor(e.layerY / paint_scale);
					drawing_data[y][x] = curPaintBrush;
					drawPaintCanvas();
				}
			}

			function paint_onMouseUp(e) {
				isPainting = false;
				saveDrawingData();
				refreshGameData();
				drawEditMap();
			}

			function drawPaintCanvas() {
				//background
				paint_ctx.fillStyle = "rgb("+palette[drawingPal][0][0]+","+palette[drawingPal][0][1]+","+palette[drawingPal][0][2]+")";
				paint_ctx.fillRect(0,0,canvas.width,canvas.height);

				//pixel color
				if (paintMode == TileType.Tile) {
					paint_ctx.fillStyle = "rgb("+palette[drawingPal][1][0]+","+palette[drawingPal][1][1]+","+palette[drawingPal][1][2]+")";
				}
				else if (paintMode == TileType.Sprite || paintMode == TileType.Avatar) {
					paint_ctx.fillStyle = "rgb("+palette[drawingPal][2][0]+","+palette[drawingPal][2][1]+","+palette[drawingPal][2][2]+")";
				}

				//draw pixels
				for (var x = 0; x < 8; x++) {
					for (var y = 0; y < 8; y++) {
						if (drawing_data[y][x] == 1) {
							paint_ctx.fillRect(x*paint_scale,y*paint_scale,1*paint_scale,1*paint_scale);
						}
					}
				}

				//draw grid
				if (drawPaintGrid) {
					paint_ctx.fillStyle = "#fff";
					for (var x = 1; x < tilesize; x++) {
						paint_ctx.fillRect(x*paint_scale,0*paint_scale,1,tilesize*paint_scale);
					}
					for (var y = 1; y < tilesize; y++) {
						paint_ctx.fillRect(0*paint_scale,y*paint_scale,tilesize*paint_scale,1);
					}
				}
			}

			function drawEditMap() {	
				//clear screen
				ctx.fillStyle = "rgb("+palette[curPal()][0][0]+","+palette[curPal()][0][1]+","+palette[curPal()][0][2]+")";
				ctx.fillRect(0,0,canvas.width,canvas.height);

				//draw map
				drawSet(set[curSet]);

				//draw grid
				console.log(curSet);
				if (drawMapGrid) {
					ctx.fillStyle = "#fff";
					for (var x = 1; x < mapsize; x++) {
						ctx.fillRect(x*tilesize*scale,0*tilesize*scale,1,mapsize*tilesize*scale);
					}
					for (var y = 1; y < mapsize; y++) {
						ctx.fillRect(0*tilesize*scale,y*tilesize*scale,mapsize*tilesize*scale,1);
					}
				}
			}

			function saveDrawingData() {
				if (paintMode == TileType.Tile) {
					//create tile if it doesn't exist
					var drw = "TIL_" + drawingId;
					if (!(drawingId in tile)) {
						tile[drawingId] = {
							drw : drw,
							col : 1
						};
					}
					//save tile drawing
					imageStore.source[drw] = [];
					for (var y = 0; y < 8; y++) {
						var ln = "";
						for (var x = 0; x < 8; x++) {
							ln += drawing_data[y][x];
						}
						imageStore.source[drw].push(ln);
					} 
					renderImages(); //rerender all images (inefficient)
				}
				else { //paintMode is Sprite or Avatar
					//new sprite
					var drw = "SPR_" + drawingId;
					if (!(drawingId in sprite)) {
						sprite[drawingId] = { //todo create default sprite creation method
							drw : drw,
							col : 2,
							set : null,
							x : -1,
							y : -1
						};
					}
					//save sprite drawing
					imageStore.source[drw] = [];
					for (var y = 0; y < 8; y++) {
						var ln = "";
						for (var x = 0; x < 8; x++) {
							ln += drawing_data[y][x];
						}
						imageStore.source[drw].push(ln);
					} 
					renderImages();
				}
			}

			function refreshGameData() {
				var gameData = serializeWorld();
				document.getElementById("game_data").value = gameData;
			}

			function on_edit_mode() {
				stopGame();
				parseWorld(document.getElementById("game_data").value); //reparse world to account for any changes during gameplay
				drawEditMap();
				listenMapEditEvents();
			}

			function on_play_mode() {
				unlistenMapEditEvents();
				load_game(document.getElementById("game_data").value);
			}

			function toggleGrid() {
				drawPaintGrid = !drawPaintGrid;
				drawPaintCanvas();
			}

			function toggleMapGrid() {
				drawMapGrid = !drawMapGrid;
				drawEditMap();
			}

			function on_change_title() {
				title = document.getElementById("titleText").value;
				refreshGameData();
			}

			function on_change_color_bg() {
				var rgb = hexToRgb( document.getElementById("backgroundColor").value );
				palette[drawingPal][0][0] = rgb.r;
				palette[drawingPal][0][1] = rgb.g;
				palette[drawingPal][0][2] = rgb.b;
				refreshGameData();
				renderImages();
				drawPaintCanvas();
				drawEditMap();
			}

			function on_change_color_tile() {
				var rgb = hexToRgb( document.getElementById("tileColor").value );
				palette[drawingPal][1][0] = rgb.r;
				palette[drawingPal][1][1] = rgb.g;
				palette[drawingPal][1][2] = rgb.b;
				refreshGameData();
				renderImages();
				drawPaintCanvas();
				drawEditMap();
			}

			function on_change_color_sprite() {
				var rgb = hexToRgb( document.getElementById("spriteColor").value );
				palette[drawingPal][2][0] = rgb.r;
				palette[drawingPal][2][1] = rgb.g;
				palette[drawingPal][2][2] = rgb.b;
				refreshGameData();
				renderImages();
				drawPaintCanvas();
				drawEditMap();
			}

			//hex-to-rgb method borrowed from stack overflow
			function hexToRgb(hex) {
				// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
				var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
				hex = hex.replace(shorthandRegex, function(m, r, g, b) {
					return r + r + g + g + b + b;
				});

				var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				return result ? {
					r: parseInt(result[1], 16),
					g: parseInt(result[2], 16),
					b: parseInt(result[3], 16)
				} : null;
			}

			function on_paint_avatar() {
				paintMode = TileType.Avatar;
				drawingId = "A";
				reloadSprite();
			}
			function on_paint_tile() {
				paintMode = TileType.Tile;
				tileIndex = 0;
				console.log(sortedTileIdList());
				drawingId = sortedTileIdList()[tileIndex];
				reloadTile();
			}
			function on_paint_sprite() {
				//todo
			}
		</script>
	</head>

	<body onload="start()">
		<div id="topbar">
			bitsy editor v0
		</div>
		<div class="panel">
			~ map ~
			<form>
				<input type="radio" name="edit mode" value="edit" onclick="on_edit_mode()" checked> edit
				<input type="radio" name="edit mode" value="play" onclick="on_play_mode()"> play
			</form>
			<canvas id="game"></canvas>
			<br>
			<button onclick="toggleMapGrid();"> grid? </button>
		</div>
		<div class="panel">
			~ paint ~ <br>
			<form>
				<input type="radio" name="paint mode" value="sprite" onclick="on_paint_avatar();" checked> avatar
				<input type="radio" name="paint mode" value="tile" onclick="on_paint_tile();"> tile
				<input type="radio" name="paint mode" value="sprite" onclick="on_paint_sprite();"> sprite
			</form>
			<button onclick="prevTile();"> < prev </button>
			<button onclick="nextTile();"> next > </button>
			<button onclick="newTile();"> + new </button>
			<br>
			<canvas id="paint"></canvas>
			<br>
			<!--
			dialog: <input type="text">
			<br>
			-->
			<!-- TODO isWall checkbox -->
			<button onclick="toggleGrid();"> grid? </button>
		</div>
		<div class="panel">
			~ colors ~ <br>
			<input type="color" value="#0052cc" id="backgroundColor" onchange="on_change_color_bg();"> background <br>
			<input type="color" value="#809fff" id="tileColor" onchange="on_change_color_tile();"> tile <br>
			<input type="color" value="#ffffff" id="spriteColor" onchange="on_change_color_sprite();"> sprite <br>
		</div>
		<div class="panel">
			~ title and export ~ <br>
			title: <input type="text" id="titleText" onchange="on_change_title();" value="Write title here"> <br>
			<!-- <button>export game</button> -->
		</div>
		<div class="panel">
			~ game data ~ <br>
			<textarea id="game_data" style="width:300px;height:300px;"></textarea>
	</body>
</html>